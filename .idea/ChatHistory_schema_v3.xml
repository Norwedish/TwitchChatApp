<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="chatSessions" value="{&quot;11be22b5-12ac-411f-bfe4-a20aeedc054b&quot;:{&quot;id&quot;:&quot;11be22b5-12ac-411f-bfe4-a20aeedc054b&quot;,&quot;name&quot;:&quot;Add a \&quot;new messages\&quot; indicator when scrolling up (auto-scroll otherwise)&quot;,&quot;timestamp&quot;:1764062509929,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/norwedish/twitchchatapp/ChatService.kt, lines\u003dALL(1-636)\npackage com.norwedish.twitchchatapp\n\nimport android.app.NotificationChannel\nimport android.app.NotificationManager\nimport android.app.Service\nimport android.content.Context\nimport android.content.Intent\nimport android.os.Binder\nimport android.os.IBinder\nimport android.util.Log\nimport androidx.core.app.NotificationCompat\nimport io.ktor.client.HttpClient\nimport io.ktor.client.engine.cio.CIO\nimport io.ktor.client.plugins.contentnegotiation.ContentNegotiation\nimport io.ktor.client.plugins.websocket.WebSockets\nimport io.ktor.client.plugins.websocket.wss\nimport io.ktor.client.request.header\nimport io.ktor.client.request.post\nimport io.ktor.client.request.setBody\nimport io.ktor.http.ContentType\nimport io.ktor.http.HttpMethod\nimport io.ktor.http.contentType\nimport io.ktor.client.plugins.websocket.DefaultClientWebSocketSession\nimport io.ktor.serialization.kotlinx.json.json\nimport io.ktor.websocket.Frame\nimport io.ktor.websocket.close\nimport io.ktor.websocket.readText\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.serialization.SerialName\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.encodeToString\nimport kotlinx.serialization.json.Json\nimport java.text.SimpleDateFormat\nimport java.util.*\n\nenum class ConnectionState {\n    DISCONNECTED,\n    CONNECTING,\n    CONNECTED,\n    ERROR\n}\n\nenum class MessageType {\n    STANDARD,\n    SUBSCRIPTION,\n    RAID,\n    ANNOUNCEMENT,\n    SYSTEM,\n    DELETED\n}\n\ndata class TwitchEmoteInfo(\n    val id: String,\n    val startIndex: Int,\n    val endIndex: Int,\n)\n\ndata class ChatMessage(\n    val id: String \u003d java.util.UUID.randomUUID().toString(),\n    val author: String?,\n    val authorLogin: String?,\n    val message: String,\n    val authorColor: String?,\n    val emotes: List\u003cParsedEmote\u003e \u003d emptyList(),\n    val badges: List\u003cString\u003e \u003d emptyList(),\n    val type: MessageType \u003d MessageType.STANDARD,\n    val timestamp: String \u003d SimpleDateFormat(\&quot;HH:mm\&quot;, Locale.getDefault()).format(Date()),\n    val tags: Map\u003cString, String\u003e \u003d emptyMap(),\n    val replyParentMsgId: String? \u003d null,\n    val replyParentUserLogin: String? \u003d null,\n    val replyParentMsgBody: String? \u003d null\n)\n\ndata class RoomState(\n    val emoteOnly: Boolean \u003d false,\n    val followersOnly: Int? \u003d null, // Minutes\n    val r9k: Boolean \u003d false,\n    val slowMode: Int? \u003d null // Seconds\n)\n\n\n// Data classes for Polls\n@Serializable\ndata class Poll(\n    @SerialName(\&quot;id\&quot;) val id: String,\n    val title: String,\n    val choices: List\u003cPollChoice\u003e,\n    val status: String, // \&quot;ACTIVE\&quot;, \&quot;COMPLETED\&quot;, \&quot;ARCHIVED\&quot;\n    @SerialName(\&quot;duration_seconds\&quot;) val duration: Int,\n    @SerialName(\&quot;broadcaster_user_id\&quot;) val broadcasterId: String\n) {\n    val totalVotes by lazy { choices.sumOf { it.votes } }\n}\n\n@Serializable\ndata class PollChoice(\n    @SerialName(\&quot;id\&quot;) val id: String,\n    val title: String,\n    @SerialName(\&quot;votes\&quot;) val votes: Int \u003d 0\n)\n\n// Data classes for GQL Voting\n@Serializable\ndata class GqlRequest(val operationName: String, val variables: GqlVariables, val extensions: GqlExtensions)\n\n@Serializable\ndata class GqlVariables(val input: GqlInput)\n\n@Serializable\ndata class GqlInput(val pollID: String, val choiceID: String)\n\n@Serializable\ndata class GqlExtensions(@SerialName(\&quot;persistedQuery\&quot;) val persistedQuery: GqlPersistedQuery)\n\n@Serializable\ndata class GqlPersistedQuery(val version: Int, val sha256Hash: String)\n\n\nclass ChatService : Service() {\n\n    private val binder \u003d ChatBinder()\n    private val serviceJob \u003d SupervisorJob()\n    private val serviceScope \u003d CoroutineScope(Dispatchers.IO + serviceJob)\n\n    private var isStarted \u003d false\n\n    private val client \u003d HttpClient(CIO) {\n        install(WebSockets)\n        install(ContentNegotiation) {\n            json(Json { ignoreUnknownKeys \u003d true })\n        }\n    }\n\n    private val _connectionState \u003d MutableStateFlow(ConnectionState.DISCONNECTED)\n    val connectionState \u003d _connectionState.asStateFlow()\n\n    private val _chatMessages \u003d MutableSharedFlow\u003cChatMessage\u003e()\n    val chatMessages \u003d _chatMessages.asSharedFlow()\n\n    private val _deletedMessageIds \u003d MutableSharedFlow\u003cString\u003e()\n    val deletedMessageIds \u003d _deletedMessageIds.asSharedFlow()\n\n    private val _deletedUserMessages \u003d MutableSharedFlow\u003cString\u003e()\n    val deletedUserMessages \u003d _deletedUserMessages.asSharedFlow()\n\n    private val _isCurrentUserModerator \u003d MutableStateFlow(false)\n    val isCurrentUserModerator \u003d _isCurrentUserModerator.asStateFlow()\n\n    private var session: DefaultClientWebSocketSession? \u003d null\n    private var connectionJob: Job? \u003d null\n    var currentChannel: String \u003d \&quot;\&quot;\n\n    private val _poll \u003d MutableStateFlow\u003cPoll?\u003e(null)\n    val poll \u003d _poll.asStateFlow()\n\n    private val _roomState \u003d MutableStateFlow\u003cRoomState?\u003e(null)\n    val roomState \u003d _roomState.asStateFlow()\n\n    private val _chatters \u003d MutableStateFlow\u003cList\u003cString\u003e\u003e(emptyList())\n    val chatters \u003d _chatters.asStateFlow()\n\n    private val currentChatters \u003d Collections.synchronizedSet(mutableSetOf\u003cString\u003e())\n\n    private val json \u003d Json { ignoreUnknownKeys \u003d true; isLenient \u003d true }\n\n    companion object {\n        const val NOTIFICATION_ID \u003d 1\n        const val CHANNEL_ID \u003d \&quot;ChatServiceChannel\&quot;\n        private const val TAG \u003d \&quot;ChatService\&quot;\n    }\n\n    inner class ChatBinder : Binder() {\n        fun getService(): ChatService \u003d this@ChatService\n    }\n\n    override fun onBind(intent: Intent): IBinder {\n        return binder\n    }\n\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        if (isStarted) {\n            Log.d(TAG, \&quot;Service already started, ignoring command.\&quot;)\n            return START_STICKY\n        }\n        isStarted \u003d true\n\n        val channelName \u003d intent?.getStringExtra(\&quot;channelName\&quot;) ?: return START_NOT_STICKY\n\n        createNotificationChannel()\n        val notification \u003d NotificationCompat.Builder(this, CHANNEL_ID)\n            .setContentTitle(\&quot;Twitch Chat\&quot;)\n            .setContentText(\&quot;Connected to #$channelName\&quot;)\n            .setSmallIcon(R.drawable.transparentlogo)\n            .setOngoing(true)\n            .build()\n\n        startForeground(NOTIFICATION_ID, notification)\n\n        connectAndJoin(channelName)\n\n        return START_STICKY\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        serviceJob.cancel()\n        disconnect()\n    }\n\n    private fun createNotificationChannel() {\n        val name \u003d \&quot;Twitch Chat Service\&quot;\n        val descriptionText \u003d \&quot;Notification channel for the chat service\&quot;\n        val importance \u003d NotificationManager.IMPORTANCE_DEFAULT\n        val channel \u003d NotificationChannel(CHANNEL_ID, name, importance).apply {\n            description \u003d descriptionText\n        }\n        val notificationManager:\n                NotificationManager \u003d getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\n        notificationManager.createNotificationChannel(channel)\n    }\n\n    fun connectAndJoin(channelName: String) {\n        if (connectionState.value \u003d\u003d ConnectionState.CONNECTED || connectionState.value \u003d\u003d ConnectionState.CONNECTING) {\n            return\n        }\n\n        val token \u003d UserManager.accessToken\n        val nick \u003d UserManager.currentUser?.login\n\n        if (token \u003d\u003d null || nick \u003d\u003d null) {\n            return\n        }\n\n        currentChannel \u003d channelName\n\n        connectionJob?.cancel()\n        currentChatters.clear() // Clear chatters for the new channel\n        _chatters.value \u003d emptyList()\n        _roomState.value \u003d null\n\n        connectionJob \u003d serviceScope.launch {\n            _connectionState.value \u003d ConnectionState.CONNECTING\n            try {\n                client.wss(\n                    method \u003d HttpMethod.Get,\n                    host \u003d \&quot;irc-ws.chat.twitch.tv\&quot;,\n                    port \u003d 443,\n                    path \u003d \&quot;\&quot;\n                ) {\n                    session \u003d this\n                    send(Frame.Text(\&quot;PASS oauth:$token\&quot;))\n                    send(Frame.Text(\&quot;NICK $nick\&quot;))\n                    send(Frame.Text(\&quot;CAP REQ :twitch.tv/membership\&quot;))\n                    send(Frame.Text(\&quot;CAP REQ :twitch.tv/tags\&quot;))\n                    send(Frame.Text(\&quot;CAP REQ :twitch.tv/commands\&quot;))\n\n                    listenToMessages(channelName)\n                }\n            } catch (e: CancellationException) {\n                // This is expected when the job is cancelled\n            } catch (e: Exception) {\n                _connectionState.value \u003d ConnectionState.ERROR\n            } finally {\n                session?.close()\n                session \u003d null\n                if (_connectionState.value !\u003d ConnectionState.ERROR) {\n                    _connectionState.value \u003d ConnectionState.DISCONNECTED\n                }\n            }\n        }\n    }\n\n    fun disconnect() {\n        _isCurrentUserModerator.value \u003d false // Reset mod status on disconnect\n        connectionJob?.cancel()\n        _poll.value \u003d null // Clear the poll when disconnecting\n        _roomState.value \u003d null\n    }\n\n    fun sendMessage(channelName: String, message: String, replyToMessageId: String? \u003d null) {\n        val activeSession \u003d session\n        if (activeSession?.isActive \u003d\u003d true \u0026\u0026 message.isNotBlank()) {\n            serviceScope.launch {\n                try {\n                    val ircMessage \u003d if (replyToMessageId !\u003d null) {\n                        \&quot;@reply-parent-msg-id\u003d$replyToMessageId PRIVMSG #$channelName :$message\&quot;\n                    } else {\n                        \&quot;PRIVMSG #$channelName :$message\&quot;\n                    }\n                    activeSession.send(Frame.Text(ircMessage))\n                } catch (e: Exception) {\n                    // Handle error\n                }\n            }\n        }\n    }\n\n    private suspend fun DefaultClientWebSocketSession.listenToMessages(channelName: String) {\n        for (frame in incoming) {\n            if (frame is Frame.Text) {\n                val messageText \u003d frame.readText().trim()\n                messageText.split(\&quot;\\r\\n\&quot;).forEach { rawMessage -\u003e\n                    if (rawMessage.startsWith(\&quot;PING\&quot;)) {\n                        send(Frame.Text(\&quot;PONG :tmi.twitch.tv\&quot;))\n                        return@forEach\n                    }\n\n                    val joinMatch \u003d Regex(\&quot;:([^!]+)!.* JOIN #\&quot;).find(rawMessage)\n                    val partMatch \u003d Regex(\&quot;:([^!]+)!.* PART #\&quot;).find(rawMessage)\n\n                    if (rawMessage.contains(\&quot; 001 \&quot;)) { // Welcome message: authentication is successful\n                        Log.d(TAG, \&quot;Authentication successful. Sending JOIN command.\&quot;)\n                        send(Frame.Text(\&quot;JOIN #$channelName\&quot;))\n                        _connectionState.value \u003d ConnectionState.CONNECTED\n                    } else if (rawMessage.contains(\&quot; 353 \&quot;)) { // NAMES list\n                        val usersPart \u003d rawMessage.substringAfterLast(\u0027:\u0027)\n                        val users \u003d usersPart.trim().split(\u0027 \u0027).filter { it.isNotBlank() }\n                        currentChatters.addAll(users)\n                        _chatters.value \u003d currentChatters.toList().sorted()\n                        Log.d(TAG, \&quot;Parsed ${users.size} chatters from NAMES. Total: ${currentChatters.size}\&quot;)\n                    } else if (rawMessage.contains(\&quot; 366 \&quot;)) { // End of NAMES list\n                        _chatters.value \u003d currentChatters.toList().sorted()\n                        Log.d(TAG, \&quot;End of NAMES list. Current chatter count: ${currentChatters.size}\&quot;)\n                        // DO NOT CLEAR THE LIST\n                    }\n                    else if (joinMatch !\u003d null) {\n                        val username \u003d joinMatch.groupValues[1]\n                        if (currentChatters.add(username)) {\n                            _chatters.value \u003d currentChatters.toList().sorted()\n                            Log.d(TAG, \&quot;User JOINED: $username. Total: ${currentChatters.size}\&quot;)\n                        }\n                    } else if (partMatch !\u003d null) {\n                        val username \u003d partMatch.groupValues[1]\n                        if (currentChatters.remove(username)) {\n                            _chatters.value \u003d currentChatters.toList().sorted()\n                            Log.d(TAG, \&quot;User PARTED: $username. Total: ${currentChatters.size}\&quot;)\n                        }\n                    } else if (rawMessage.contains(\&quot;USERSTATE\&quot;)) {\n                        handleUserState(rawMessage)\n                    } else if (rawMessage.contains(\&quot;USERNOTICE\&quot;) \u0026\u0026 rawMessage.contains(\&quot;msg-id\u003dchannel.poll.\&quot;)) {\n                        handlePollNotice(rawMessage)\n                    } else if (rawMessage.contains(\&quot;CLEARMSG\&quot;)) {\n                        handleClearMessage(rawMessage)\n                    } else if (rawMessage.contains(\&quot;CLEARCHAT\&quot;)) {\n                        handleClearChat(rawMessage)\n                    } else if (rawMessage.contains(\&quot;ROOMSTATE\&quot;)) {\n                        handleRoomState(rawMessage)\n                    } else if (rawMessage.contains(\&quot;NOTICE\&quot;)) {\n                        handleNotice(rawMessage)\n                    }\n                    else {\n                        parseMessage(rawMessage)?.let {\n                            serviceScope.launch {\n                                _chatMessages.emit(it)\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private fun handleNotice(rawMessage: String) {\n        val tagsPart \u003d rawMessage.substringAfter(\u0027@\u0027).substringBefore(\&quot; :\&quot;)\n        val messagePart \u003d rawMessage.substringAfter(\&quot;:\&quot;)\n        val tags \u003d tagsPart.split(\u0027;\u0027).associate {\n            val parts \u003d it.split(\u0027\u003d\u0027, limit \u003d 2)\n            if (parts.size \u003d\u003d 2) parts[0] to parts[1] else parts[0] to \&quot;\&quot;\n        }\n        val msgId \u003d tags[\&quot;msg-id\&quot;]\n        val systemMessage \u003d messagePart\n        serviceScope.launch {\n            _chatMessages.emit(\n                ChatMessage(\n                author \u003d null,\n                authorLogin \u003d null,\n                message \u003d systemMessage,\n                authorColor \u003d null,\n                type \u003d MessageType.SYSTEM,\n                tags \u003d tags\n            )\n            )\n        }\n    }\n\n    private fun handleClearMessage(rawMessage: String) {\n        val tags \u003d rawMessage.substringAfter(\u0027@\u0027).substringBefore(\&quot; :\&quot;).split(\u0027;\u0027).associate {\n            val parts \u003d it.split(\u0027\u003d\u0027, limit \u003d 2)\n            if (parts.size \u003d\u003d 2) parts[0] to parts[1] else parts[0] to \&quot;\&quot;\n        }\n        val targetMessageId \u003d tags[\&quot;target-msg-id\&quot;]\n        if (targetMessageId !\u003d null) {\n            serviceScope.launch {\n                _deletedMessageIds.emit(targetMessageId)\n            }\n        }\n    }\n\n    private fun handleClearChat(rawMessage: String) {\n        val targetUser \u003d rawMessage.substringAfterLast(\&quot;:\&quot;, \&quot;\&quot;).trim()\n        if (targetUser.isNotEmpty()) {\n            serviceScope.launch {\n                _deletedUserMessages.emit(targetUser)\n            }\n        }\n    }\n\n    private fun handleUserState(rawMessage: String) {\n        val tagsPart \u003d rawMessage.substringAfter(\u0027@\u0027).substringBefore(\&quot; :\&quot;)\n        val tags \u003d tagsPart.split(\u0027;\u0027).associate {\n            val parts \u003d it.split(\u0027\u003d\u0027, limit \u003d 2)\n            if (parts.size \u003d\u003d 2) parts[0] to parts[1] else parts[0] to \&quot;\&quot;\n        }\n        val badges \u003d tags[\&quot;badges\&quot;]?.split(\u0027,\u0027) ?: emptyList()\n        val isMod \u003d badges.any { it.startsWith(\&quot;moderator\&quot;) || it.startsWith(\&quot;broadcaster\&quot;) }\n        if (isMod !\u003d _isCurrentUserModerator.value) {\n            _isCurrentUserModerator.value \u003d isMod\n        }\n    }\n\n    private fun handlePollNotice(rawMessage: String) {\n        val tagsPart \u003d rawMessage.substringAfter(\u0027@\u0027).substringBefore(\&quot; :\&quot;)\n        val tags \u003d tagsPart.split(\u0027;\u0027).associate {\n            val parts \u003d it.split(\u0027\u003d\u0027, limit \u003d 2)\n            if (parts.size \u003d\u003d 2) parts[0] to parts[1] else parts[0] to \&quot;\&quot;\n        }\n\n        val msgId \u003d tags[\&quot;msg-id\&quot;] ?: return\n\n        when (msgId) {\n            \&quot;channel.poll.begin\&quot;, \&quot;channel.poll.progress\&quot; -\u003e {\n                try {\n                    _poll.value \u003d parsePollFromTags(tags)\n                } catch (e: Exception) {\n                    Log.e(TAG, \&quot;Failed to parse poll data from tags\&quot;, e)\n                }\n            }\n            \&quot;channel.poll.end\&quot; -\u003e {\n                _poll.value \u003d null\n            }\n        }\n    }\n\n    private fun parsePollFromTags(tags: Map\u003cString, String\u003e): Poll {\n        val choices \u003d mutableListOf\u003cPollChoice\u003e()\n        for (i in 1..5) { // Twitch polls have a max of 5 choices\n            val choiceId \u003d tags[\&quot;poll-choice-${i}-id\&quot;] ?: break\n            val choiceTitle \u003d tags[\&quot;poll-choice-${i}-title\&quot;] ?: \&quot;\&quot;\n            val choiceVotes \u003d tags[\&quot;poll-choice-${i}-votes\&quot;]?.toIntOrNull() ?: 0\n            choices.add(PollChoice(id \u003d choiceId, title \u003d choiceTitle, votes \u003d choiceVotes))\n        }\n\n        return Poll(\n            id \u003d tags[\&quot;poll-id\&quot;] ?: \&quot;\&quot;,\n            title \u003d tags[\&quot;poll-title\&quot;] ?: \&quot;\&quot;,\n            choices \u003d choices,\n            status \u003d tags[\&quot;poll-status\&quot;]?.uppercase() ?: \&quot;ACTIVE\&quot;,\n            duration \u003d tags[\&quot;poll-duration-seconds\&quot;]?.toIntOrNull() ?: 0,\n            broadcasterId \u003d tags[\&quot;room-id\&quot;] ?: \&quot;\&quot;\n        )\n    }\n\n    private fun handleRoomState(rawMessage: String) {\n        val tagsPart \u003d rawMessage.substringAfter(\u0027@\u0027).substringBefore(\&quot; :\&quot;)\n        val tags \u003d tagsPart.split(\u0027;\u0027).associate {\n            val parts \u003d it.split(\u0027\u003d\u0027, limit \u003d 2)\n            if (parts.size \u003d\u003d 2) parts[0] to parts[1] else parts[0] to \&quot;\&quot;\n        }\n\n        _roomState.value \u003d RoomState(\n            emoteOnly \u003d tags[\&quot;emote-only\&quot;] \u003d\u003d \&quot;1\&quot;,\n            followersOnly \u003d tags[\&quot;followers-only\&quot;]?.toIntOrNull(),\n            r9k \u003d tags[\&quot;r9k\&quot;] \u003d\u003d \&quot;1\&quot;,\n            slowMode \u003d tags[\&quot;slow\&quot;]?.toIntOrNull()\n        )\n    }\n    private fun unescapeTagValue(value: String?): String {\n        if (value \u003d\u003d null) return \&quot;\&quot;\n        return value.replace(\&quot;\\\\s\&quot;, \&quot; \&quot;)\n            .replace(\&quot;\\\\:\&quot;, \&quot;;\&quot;)\n            .replace(\&quot;\\\\r\&quot;, \&quot;\\r\&quot;)\n            .replace(\&quot;\\\\n\&quot;, \&quot;\\n\&quot;)\n            .replace(\&quot;\\\\\\\\\&quot;, \&quot;\\\\\&quot;)\n    }\n\n    private fun parseMessage(rawMessage: String): ChatMessage? {\n        val pattern \u003d Regex(\&quot;\&quot;\&quot;^(?:@([^ ]+) )?(?::([^!]+)![^ ]+ )?([^ ]+)(?: (?!:)([^ ]+))?(?: :(.+))?$\&quot;\&quot;\&quot;)\n        val match \u003d pattern.find(rawMessage)\n\n        if (match !\u003d null) {\n            val command \u003d match.groupValues[3]\n            if (command !\u003d \&quot;PRIVMSG\&quot; \u0026\u0026 command !\u003d \&quot;USERNOTICE\&quot;) {\n                return null\n            }\n\n            val tagsPart \u003d match.groupValues[1]\n            val loginName \u003d match.groupValues[2]\n            var userMessage \u003d match.groupValues[5]\n\n            var color: String? \u003d null\n            var displayName: String? \u003d null\n            var twitchEmotes: List\u003cTwitchEmoteInfo\u003e \u003d emptyList()\n            var badges: List\u003cString\u003e \u003d emptyList()\n            var messageType \u003d MessageType.STANDARD\n            var tags: Map\u003cString, String\u003e \u003d emptyMap()\n            var finalMessage \u003d \&quot;\&quot;\n\n            if (tagsPart.isNotEmpty()) {\n                tags \u003d tagsPart.split(\u0027;\u0027).associate {\n                    val parts \u003d it.split(\u0027\u003d\u0027, limit \u003d 2)\n                    if (parts.size \u003d\u003d 2) parts[0] to unescapeTagValue(parts[1]) else parts[0] to \&quot;\&quot;\n                }\n                color \u003d tags[\&quot;color\&quot;]\n                displayName \u003d tags[\&quot;display-name\&quot;]\n\n                val badgesTag \u003d tags[\&quot;badges\&quot;] ?: \&quot;\&quot;\n                if (badgesTag.isNotBlank()) {\n                    badges \u003d badgesTag.split(\&quot;,\&quot;).map { it.split(\&quot;/\&quot;).first() }\n                }\n\n                val emoteTag \u003d tags[\&quot;emotes\&quot;] ?: \&quot;\&quot;\n                if (emoteTag.isNotEmpty()) {\n                    // Note: Emote indices are based on the user\u0027s message, not the system message\n                    twitchEmotes \u003d EmoteParser.parse(emoteTag).map { TwitchEmoteInfo(it.id, it.startIndex, it.endIndex) }\n                }\n\n                if (command \u003d\u003d \&quot;USERNOTICE\&quot;) {\n                    val msgId \u003d tags[\&quot;msg-id\&quot;]\n\n                    if (msgId?.startsWith(\&quot;channel.poll.\&quot;) \u003d\u003d true) {\n                        return null // Handled separately\n                    }\n\n                    messageType \u003d when (msgId) {\n                        \&quot;sub\&quot;, \&quot;resub\&quot;, \&quot;subgift\&quot;, \&quot;anonsubgift\&quot;, \&quot;submysterygift\&quot;, \&quot;anonsubmysterygift\&quot;, \&quot;primepaidupgrade\&quot;, \&quot;giftpaidupgrade\&quot; -\u003e MessageType.SUBSCRIPTION\n                        \&quot;raid\&quot; -\u003e MessageType.RAID\n                        \&quot;announcement\&quot; -\u003e MessageType.ANNOUNCEMENT\n                        else -\u003e messageType\n                    }\n\n                    // For USERNOTICE, the main content is the system message.\n                    finalMessage \u003d tags[\&quot;system-msg\&quot;] ?: \&quot;\&quot;\n                    if (userMessage.isNotEmpty()) {\n                        finalMessage +\u003d \&quot;\\n$userMessage\&quot;\n                    }\n\n                } else { // PRIVMSG\n                    finalMessage \u003d userMessage\n                    val isReply \u003d tags.containsKey(\&quot;reply-parent-msg-id\&quot;)\n                    if (isReply) {\n                        val replyTo \u003d tags[\&quot;reply-parent-user-login\&quot;]\n                        if (replyTo !\u003d null \u0026\u0026 finalMessage.startsWith(\&quot;@$replyTo\&quot;, ignoreCase \u003d true)) {\n                            val endOfMention \u003d finalMessage.indexOf(\u0027 \u0027)\n                            if (endOfMention !\u003d -1) {\n                                finalMessage \u003d finalMessage.substring(endOfMention + 1)\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Emotes are parsed from the user\u0027s raw message, not the combined final message\n            val parsedTwitchEmotes \u003d twitchEmotes.map { twitchEmote -\u003e\n                val code \u003d userMessage.substring(twitchEmote.startIndex, twitchEmote.endIndex + 1)\n                ParsedEmote(\n                    emote \u003d Emote(\n                        id \u003d twitchEmote.id,\n                        code \u003d code,\n                        url \u003d \&quot;https://static-cdn.jtvnw.net/emoticons/v2/${twitchEmote.id}/default/dark/1.0\&quot;,\n                        provider \u003d EmoteProvider.TWITCH\n                    ),\n                    startIndex \u003d twitchEmote.startIndex,\n                    endIndex \u003d twitchEmote.endIndex\n                )\n            }\n\n            val thirdPartyEmotes \u003d EmoteManager.parseThirdPartyEmotes(userMessage)\n            val allEmotes \u003d (parsedTwitchEmotes + thirdPartyEmotes).sortedBy { it.startIndex }\n\n            var finalColor \u003d color\n            if (finalColor.isNullOrEmpty()) {\n                finalColor \u003d \&quot;#8A2BE2\&quot; // Default color\n            } else if (finalColor.equals(\&quot;#000000\&quot;, ignoreCase \u003d true)) {\n                finalColor \u003d \&quot;#FFFFFF\&quot; // Change black to white for readability\n            }\n\n            val author \u003d displayName?.takeIf { it.isNotEmpty() } ?: loginName\n\n            return ChatMessage(\n                author \u003d author,\n                authorLogin \u003d loginName,\n                message \u003d finalMessage, // This is now the correctly combined/cleaned message\n                authorColor \u003d finalColor,\n                emotes \u003d allEmotes, // Emotes are based on the original user message\n                badges \u003d badges,\n                type \u003d messageType,\n                tags \u003d tags,\n                replyParentMsgId \u003d tags[\&quot;reply-parent-msg-id\&quot;],\n                replyParentUserLogin \u003d tags[\&quot;reply-parent-user-login\&quot;],\n                replyParentMsgBody \u003d tags[\&quot;reply-parent-msg-body\&quot;]\n            )\n        }\n        return null\n    }\n\n\n    fun voteOnPoll(pollId: String, choiceId: String) {\n        serviceScope.launch {\n            val token \u003d UserManager.accessToken ?: return@launch\n            try {\n                val request \u003d GqlRequest(\n                    operationName \u003d \&quot;PollVote\&quot;,\n                    variables \u003d GqlVariables(input \u003d GqlInput(pollID \u003d pollId, choiceID \u003d choiceId)),\n                    extensions \u003d GqlExtensions(\n                        persistedQuery \u003d GqlPersistedQuery(\n                            version \u003d 1,\n                            sha256Hash \u003d \&quot;968dba31919a2d89369931b753472097951c3a64b9795029ba26a9096734e064\&quot;\n                        )\n                    )\n                )\n\n                client.post(\&quot;https://gql.twitch.tv/gql\&quot;) {\n                    header(\&quot;Authorization\&quot;, \&quot;OAuth $token\&quot;)\n                    contentType(ContentType.Application.Json)\n                    setBody(json.encodeToString(request))\n                }\n            } catch (e: Exception) {\n                // Handle GQL error\n            }\n        }\n    }\n}\n```\n\u003c/current_file\u003e\n\n\n\u003cattached_files\u003e\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/norwedish/twitchchatapp/ChatScreen.kt, lines\u003dALL(1-1073)\npackage com.norwedish.twitchchatapp\n\nimport android.content.ComponentName\nimport android.content.Context\nimport android.content.Intent\nimport android.content.ServiceConnection\nimport android.graphics.Color as AndroidColor\nimport android.os.IBinder\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.core.animate\nimport androidx.compose.animation.core.animateFloatAsState\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.gestures.detectHorizontalDragGestures\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.grid.GridCells\nimport androidx.compose.foundation.lazy.grid.LazyVerticalGrid\nimport androidx.compose.foundation.lazy.grid.items\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.foundation.lazy.rememberLazyListState\nimport androidx.compose.foundation.shape.CircleShape\nimport androidx.compose.foundation.text.ClickableText\nimport androidx.compose.foundation.text.KeyboardActions\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.material.ExperimentalMaterialApi\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.automirrored.filled.Reply\nimport androidx.compose.material.icons.automirrored.filled.Send\nimport androidx.compose.material.icons.filled.*\nimport androidx.compose.material.pullrefresh.PullRefreshIndicator\nimport androidx.compose.material.pullrefresh.pullRefresh\nimport androidx.compose.material.pullrefresh.rememberPullRefreshState\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.* \nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.draw.clip\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.graphics.graphicsLayer\nimport androidx.compose.ui.input.pointer.pointerInput\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalSoftwareKeyboardController\nimport androidx.compose.ui.platform.LocalUriHandler\nimport androidx.compose.ui.text.SpanStyle\nimport androidx.compose.ui.text.buildAnnotatedString\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.input.ImeAction\nimport androidx.compose.ui.text.input.KeyboardCapitalization\nimport androidx.compose.ui.text.input.TextFieldValue\nimport androidx.compose.ui.text.style.TextAlign\nimport androidx.compose.ui.text.style.TextDecoration\nimport androidx.compose.ui.text.withStyle\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport coil.compose.AsyncImage\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.foundation.shape.RoundedCornerShape\nimport kotlinx.coroutines.flow.distinctUntilChanged\nimport kotlinx.coroutines.launch\nimport java.time.Instant\nimport java.time.temporal.ChronoUnit\n\n\n// Define sealed classes for our message tokens at the top level\nsealed class MessageToken\ndata class TextToken(val text: String) : MessageToken()\ndata class EmoteToken(val code: String, val url: String) : MessageToken()\ndata class UrlToken(val url: String) : MessageToken()\n\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class, ExperimentalMaterialApi::class)\n@Composable\nfun ChatScreen(\n    channelName: String,\n    twitchUserId: String,\n    displayName: String,\n    profileImageUrl: String,\n    viewModel: ChatViewModel,\n    onNavigateBack: () -\u003e Unit\n) {\n    val context \u003d LocalContext.current\n\n    DisposableEffect(channelName, twitchUserId) {\n        viewModel.prepareForChannel(channelName, twitchUserId)\n\n        val serviceIntent \u003d Intent(context, ChatService::class.java).apply {\n            putExtra(\&quot;channelName\&quot;, channelName)\n            putExtra(\&quot;twitchUserId\&quot;, twitchUserId)\n        }\n        context.startService(serviceIntent)\n\n        val serviceConnection \u003d object : ServiceConnection {\n            override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n                val binder \u003d service as ChatService.ChatBinder\n                viewModel.setChatService(binder.getService())\n            }\n\n            override fun onServiceDisconnected(name: ComponentName?) {\n                // Handle disconnection\n            }\n        }\n\n        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)\n\n        onDispose {\n            context.unbindService(serviceConnection)\n            context.stopService(serviceIntent)\n        }\n    }\n\n    val connectionState by viewModel.connectionState.collectAsState()\n    val messages by viewModel.messages.collectAsState()\n    val inputMessage by viewModel.inputMessage.collectAsState()\n    val isEmoteMenuVisible by viewModel.isEmoteMenuVisible.collectAsState()\n    val availableEmotes by viewModel.availableEmotes.collectAsState()\n    val listState \u003d rememberLazyListState()\n    val isKeyboardVisible \u003d WindowInsets.isImeVisible\n    val keyboardController \u003d LocalSoftwareKeyboardController.current\n    val isCurrentUserModerator by viewModel.isCurrentUserModerator.collectAsState()\n    val selectedUserForProfile by viewModel.selectedUserForProfile.collectAsState()\n    val viewerCount by viewModel.viewerCount.collectAsState()\n    val streamTitle by viewModel.streamTitle.collectAsState()\n    val poll by viewModel.poll.collectAsState()\n    val isChatterListVisible by viewModel.isChatterListVisible.collectAsState()\n    val chatters by viewModel.chatters.collectAsState()\n    val isChattersLoading by viewModel.isChattersLoading.collectAsState()\n    val userSuggestions by viewModel.userSuggestions.collectAsState()\n    val showUserSuggestions by viewModel.showUserSuggestions.collectAsState()\n    val roomState by viewModel.roomState.collectAsState()\n    val replyToMessage by viewModel.replyToMessage.collectAsState()\n    val followRelationship by viewModel.followRelationship.collectAsState()\n    val unreadMessageCount by viewModel.unreadMessageCount.collectAsState()\n\n    if (isChatterListVisible) {\n        val sheetState \u003d rememberModalBottomSheetState(skipPartiallyExpanded \u003d true)\n        ModalBottomSheet(onDismissRequest \u003d { viewModel.onChatterListDismissed() }, sheetState \u003d sheetState) {\n            ChatterListScreen(\n                chatters \u003d chatters,\n                isLoading \u003d isChattersLoading,\n                onRefresh \u003d { viewModel.fetchChatters() },\n                profileImageUrl \u003d profileImageUrl,\n                displayName \u003d displayName,\n                streamTitle \u003d streamTitle,\n                viewerCount \u003d viewerCount\n            )\n        }\n    }\n\n    if (selectedUserForProfile !\u003d null) {\n        val userMessages \u003d messages.filter { it.author \u003d\u003d selectedUserForProfile?.author }\n        UserInfoDialog(\n            user \u003d selectedUserForProfile!!,\n            messages \u003d userMessages,\n            onDismiss \u003d { viewModel.onDismissUserProfile() }\n        )\n    }\n\n    BackHandler(enabled \u003d isEmoteMenuVisible) {\n        viewModel.onEmoteMenuToggled()\n    }\n\n    LaunchedEffect(isKeyboardVisible) {\n        if (isKeyboardVisible \u0026\u0026 isEmoteMenuVisible) {\n            viewModel.onEmoteMenuToggled()\n        }\n    }\n\n    val coroutineScope \u003d rememberCoroutineScope()\n\n    LaunchedEffect(listState) {\n        snapshotFlow { listState.firstVisibleItemIndex \u003d\u003d 0 }\n            .distinctUntilChanged()\n            .collect { isAtBottom -\u003e\n                viewModel.onScrollStateChanged(isAtBottom)\n            }\n    }\n\n    LaunchedEffect(Unit) {\n        viewModel.scrollToBottom.collect {\n            coroutineScope.launch {\n                listState.animateScrollToItem(0)\n            }\n        }\n    }\n\n    Scaffold(\n        topBar \u003d {\n            TopAppBar(\n                title \u003d {\n                    Row(\n                        verticalAlignment \u003d Alignment.CenterVertically,\n                        modifier \u003d Modifier.clickable { viewModel.onChatterListRequested() }\n                    ) {\n                        AsyncImage(\n                            model \u003d profileImageUrl,\n                            contentDescription \u003d \&quot;Streamer avatar\&quot;,\n                            modifier \u003d Modifier\n                                .size(40.dp)\n                                .clip(CircleShape)\n                        )\n                        Spacer(modifier \u003d Modifier.width(8.dp))\n                        Column {\n                            Row(verticalAlignment \u003d Alignment.CenterVertically) {\n                                Text(text \u003d displayName)\n                                viewerCount?.let {\n                                    Text(\n                                        text \u003d \&quot;    ${formatViewerCount(it)} viewers\&quot;,\n                                        fontSize \u003d 12.sp,\n                                        color \u003d Color.Red\n                                    )\n                                }\n                            }\n                            streamTitle?.let {\n                                Text(\n                                    text \u003d it,\n                                    fontSize \u003d 12.sp,\n                                    color \u003d MaterialTheme.colorScheme.onSurfaceVariant\n                                )\n                            }\n                        }\n                    }\n                },\n                navigationIcon \u003d {\n                    IconButton(onClick \u003d onNavigateBack) {\n                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription \u003d \&quot;Back\&quot;)\n                    }\n                }\n            )\n        }\n    ) { paddingValues -\u003e\n        Column(\n            Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n                .navigationBarsPadding()\n                .imePadding()\n        ) {\n            poll?.let {\n                PollCard(poll \u003d it, onVote \u003d { pollId, choiceId -\u003e\n                    viewModel.voteOnPoll(pollId, choiceId)\n                })\n            }\n            Box(modifier \u003d Modifier.weight(1f)) {\n                LazyColumn(\n                    modifier \u003d Modifier.fillMaxSize(),\n                    state \u003d listState,\n                    verticalArrangement \u003d Arrangement.spacedBy(4.dp),\n                    contentPadding \u003d PaddingValues(horizontal \u003d 16.dp, vertical \u003d 8.dp),\n                    reverseLayout \u003d true\n                ) {\n                    items(messages.reversed(), key \u003d { it.id }) { message -\u003e\n                        ChatMessageItem(\n                            message \u003d message,\n                            isCurrentUserModerator \u003d isCurrentUserModerator,\n                            onShowProfile \u003d { viewModel.onShowUserProfile(message) },\n                            onTimeout \u003d { message.author?.let { viewModel.onTimeout(it) } },\n                            onBan \u003d { message.author?.let { viewModel.onBan(it) } },\n                            onReply \u003d { viewModel.onReply(message) }\n                        )\n                    }\n                }\n\n                if (messages.isEmpty()) {\n                    Box(modifier \u003d Modifier.fillMaxSize(), contentAlignment \u003d Alignment.Center) {\n                        Text(\n                            text \u003d when (connectionState) {\n                                ConnectionState.CONNECTING -\u003e \&quot;Connecting to chat...\&quot;\n                                ConnectionState.CONNECTED -\u003e \&quot;Connected, waiting for messages...\&quot;\n                                ConnectionState.ERROR -\u003e \&quot;Connection error\&quot;\n                                ConnectionState.DISCONNECTED -\u003e \&quot;Disconnected\&quot;\n                            },\n                            style \u003d MaterialTheme.typography.bodyMedium,\n                            color \u003d when (connectionState) {\n                                ConnectionState.CONNECTED -\u003e Color.Green\n                                ConnectionState.ERROR -\u003e MaterialTheme.colorScheme.error\n                                else -\u003e MaterialTheme.colorScheme.onSurface.copy(alpha \u003d 0.6f)\n                            }\n                        )\n                    }\n                }\n            }\n            // Room State / Message Count Bar\n            if (roomState !\u003d null) {\n                val roomStatusText \u003d buildString {\n                    if (roomState!!.emoteOnly) append(\&quot;Emote-only \&quot;)\n                    roomState!!.followersOnly?.let { followersOnlyDuration -\u003e\n                        val followedAt \u003d followRelationship?.followedAt?.let { time -\u003e Instant.parse(time) }\n                        val now \u003d Instant.now()\n\n                        val userFollowDuration \u003d if (followedAt !\u003d null) {\n                            ChronoUnit.MINUTES.between(followedAt, now)\n                        } else {\n                            -1\n                        }\n\n                        if (followersOnlyDuration \u003e 0 \u0026\u0026 userFollowDuration \u003c followersOnlyDuration) {\n                            append(\&quot;Followers-only ($followersOnlyDuration min) \&quot;)\n                        } else if (followersOnlyDuration \u003d\u003d 0 \u0026\u0026 followRelationship \u003d\u003d null) {\n                            append(\&quot;Followers-only \&quot;)\n                        }\n                    }\n                    if (roomState!!.r9k) append(\&quot;R9K \&quot;)\n                    roomState!!.slowMode?.let { if (it \u003e 0) append(\&quot;Slow mode ($it s) \&quot;) }\n                }.trim()\n\n                if (roomStatusText.isNotEmpty()) {\n                    Box(\n                        modifier \u003d Modifier\n                            .fillMaxWidth()\n                            .padding(horizontal \u003d 16.dp, vertical \u003d 4.dp),\n                        contentAlignment \u003d Alignment.Center\n                    ) {\n                        Text(\n                            text \u003d roomStatusText,\n                            style \u003d MaterialTheme.typography.bodySmall,\n                            color \u003d MaterialTheme.colorScheme.onSurfaceVariant\n                        )\n                    }\n                }\n            }\n\n            AnimatedVisibility(visible \u003d unreadMessageCount \u003e 0) {\n                Button(\n                    onClick \u003d { viewModel.jumpToBottom() },\n                    modifier \u003d Modifier\n                        .fillMaxWidth()\n                        .padding(horizontal \u003d 16.dp, vertical \u003d 8.dp)\n                ) {\n                    Icon(Icons.Default.ArrowDownward, contentDescription \u003d \&quot;Scroll to bottom\&quot;)\n                    Spacer(modifier \u003d Modifier.width(8.dp))\n                    Text(text \u003d \&quot;$unreadMessageCount new messages\&quot;)\n                }\n            }\n            \n            // Removed the `currentMessageCount` display block\n            if (showUserSuggestions) {\n                LazyColumn(\n                    modifier \u003d Modifier\n                        .heightIn(max \u003d 150.dp) // Made the list a bit shorter\n                        .fillMaxWidth()\n                        .padding(horizontal \u003d 16.dp, vertical \u003d 8.dp) // Add some padding\n                        .clip(RoundedCornerShape(8.dp)) // Give it rounded corners\n                        .background(MaterialTheme.colorScheme.surfaceVariant),\n                    reverseLayout \u003d true\n                ) {\n                    items(userSuggestions.reversed()) { username -\u003e\n                        Text(\n                            text \u003d username,\n                            modifier \u003d Modifier\n                                .fillMaxWidth()\n                                .clickable { viewModel.onUserSuggestionSelected(username) }\n                                .padding(12.dp)\n                        )\n                    }\n                }\n            }\n\n            if (connectionState \u003d\u003d ConnectionState.CONNECTED) {\n                Column {\n                    AnimatedVisibility(visible \u003d replyToMessage !\u003d null) {\n                        replyToMessage?.let { reply -\u003e\n                            Row(\n                                modifier \u003d Modifier\n                                    .fillMaxWidth()\n                                    .background(MaterialTheme.colorScheme.surfaceVariant)\n                                    .padding(horizontal \u003d 16.dp, vertical \u003d 8.dp),\n                                verticalAlignment \u003d Alignment.CenterVertically\n                            ) {\n                                Icon(Icons.AutoMirrored.Filled.Reply, contentDescription \u003d \&quot;Replying to\&quot;, modifier \u003d Modifier.size(16.dp))\n                                Spacer(modifier \u003d Modifier.width(8.dp))\n                                Column(modifier \u003d Modifier.weight(1f)) {\n                                    Text(\n                                        text \u003d \&quot;Replying to ${reply.authorLogin ?: reply.author}\&quot;,\n                                        style \u003d MaterialTheme.typography.bodySmall,\n                                        color \u003d MaterialTheme.colorScheme.onSurfaceVariant,\n                                        fontWeight \u003d FontWeight.Bold\n                                    )\n                                    Text(\n                                        text \u003d reply.message.take(50) + if (reply.message.length \u003e 50) \&quot;...\&quot; else \&quot;\&quot;,\n                                        style \u003d MaterialTheme.typography.bodySmall,\n                                        color \u003d MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha \u003d 0.7f)\n                                    )\n                                }\n                                IconButton(onClick \u003d { viewModel.clearReply() }) {\n                                    Icon(Icons.Default.Close, contentDescription \u003d \&quot;Clear reply\&quot;)\n                                }\n                            }\n                        }\n                    }\n                    ChatInputBar(\n                        text \u003d inputMessage,\n                        onTextChanged \u003d { viewModel.onInputChanged(it) },\n                        onSendClick \u003d { viewModel.sendMessage() },\n                        onEmoteClick \u003d {\n                            keyboardController?.hide()\n                            viewModel.onEmoteMenuToggled()\n                        }\n                    )\n                }\n            }\n\n            if (isEmoteMenuVisible) {\n                Box(\n                    modifier \u003d Modifier\n                        .fillMaxWidth()\n                        .height(250.dp)\n                        .background(MaterialTheme.colorScheme.surfaceVariant)\n                ) {\n                    LazyVerticalGrid(\n                        columns \u003d GridCells.Adaptive(minSize \u003d 48.dp),\n                        contentPadding \u003d PaddingValues(8.dp)\n                    ) {\n                        items(availableEmotes, key \u003d { it.id }) { emote -\u003e\n                            IconButton(onClick \u003d { viewModel.onEmoteSelected(emote.code) }) {\n                                AsyncImage(\n                                    model \u003d emote.url,\n                                    contentDescription \u003d emote.code,\n                                    modifier \u003d Modifier.size(32.dp)\n                                )\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nprivate fun HighlightedTextToken(token: TextToken, isDeleted: Boolean, modifier: Modifier \u003d Modifier) {\n    val currentUserDisplayName \u003d UserManager.currentUser?.displayName ?: \&quot;\&quot;\n    if (currentUserDisplayName.isBlank() || isDeleted) {\n        Text(\n            text \u003d token.text,\n            modifier \u003d modifier,\n            fontSize \u003d 14.sp,\n            color \u003d if (isDeleted) Color.Gray else MaterialTheme.colorScheme.onSurface\n        )\n        return\n    }\n\n    val annotatedString \u003d buildAnnotatedString {\n        val mentionPattern \u003d \&quot;\\\\b@?${Regex.escape(currentUserDisplayName)}\\\\b\&quot;.toRegex(RegexOption.IGNORE_CASE)\n        var lastIndex \u003d 0\n        mentionPattern.findAll(token.text).forEach { matchResult -\u003e\n            val startIndex \u003d matchResult.range.first\n            val endIndex \u003d matchResult.range.last + 1\n\n            if (startIndex \u003e lastIndex) {\n                append(token.text.substring(lastIndex, startIndex))\n            }\n\n            withStyle(style \u003d SpanStyle(\n                fontWeight \u003d FontWeight.Bold,\n                color \u003d MaterialTheme.colorScheme.primary,\n                background \u003d MaterialTheme.colorScheme.primary.copy(alpha \u003d 0.2f)\n            )) {\n                append(token.text.substring(startIndex, endIndex))\n            }\n            lastIndex \u003d endIndex\n        }\n        if (lastIndex \u003c token.text.length) {\n            append(token.text.substring(lastIndex))\n        }\n    }\n\n    Text(\n        text \u003d annotatedString,\n        modifier \u003d modifier,\n        fontSize \u003d 14.sp,\n        color \u003d MaterialTheme.colorScheme.onSurface\n    )\n}\n\n@OptIn(ExperimentalLayoutApi::class, ExperimentalFoundationApi::class)\n@Composable\nfun ChatMessageItem(\n    message: ChatMessage,\n    isCurrentUserModerator: Boolean,\n    onShowProfile: () -\u003e Unit,\n    onTimeout: () -\u003e Unit,\n    onBan: () -\u003e Unit,\n    onReply: (ChatMessage) -\u003e Unit\n) {\n    val isDeleted \u003d message.type \u003d\u003d MessageType.DELETED\n    val authorColor \u003d when {\n        isDeleted -\u003e Color.Gray\n        else -\u003e try {\n            Color(AndroidColor.parseColor(message.authorColor ?: \&quot;#8A2BE2\&quot;))\n        } catch (e: IllegalArgumentException) {\n            Color(0xFF8A2BE2.toInt())\n        }\n    }\n\n    val uriHandler \u003d LocalUriHandler.current\n    var showMenu by remember { mutableStateOf(false) }\n\n    // 1. Tokenize the message\n    val tokens \u003d remember(message.message, message.emotes) {\n        val tokenList \u003d mutableListOf\u003cMessageToken\u003e()\n        val urlRegex \u003d \&quot;\&quot;\&quot;(https?://\\S+)\&quot;\&quot;\&quot;.toRegex()\n\n        val specialParts \u003d mutableListOf\u003cPair\u003cIntRange, MessageToken\u003e\u003e()\n\n        // Add emotes from message tags\n        message.emotes.forEach { emoteInfo -\u003e\n            val range \u003d emoteInfo.startIndex..emoteInfo.endIndex\n            specialParts.add(range to EmoteToken(emoteInfo.emote.code, emoteInfo.emote.url))\n        }\n\n        // Find and add URLs, avoiding overlap with emotes\n        urlRegex.findAll(message.message).forEach { matchResult -\u003e\n            val urlRange \u003d matchResult.range\n            val overlapsWithEmote \u003d specialParts.any { (emoteRange, token) -\u003e\n                token is EmoteToken \u0026\u0026 urlRange.first \u003c\u003d emoteRange.last \u0026\u0026 urlRange.last \u003e\u003d emoteRange.first\n            }\n            if (!overlapsWithEmote) {\n                specialParts.add(urlRange to UrlToken(matchResult.value))\n            }\n        }\n\n        // Sort by start index to process the message in order\n        specialParts.sortBy { it.first.first }\n\n        var lastIndex \u003d 0\n        specialParts.forEach { (range, token) -\u003e\n            // Add plain text part before the current special part\n            if (range.first \u003e lastIndex) {\n                tokenList.add(TextToken(message.message.substring(lastIndex, range.first)))\n            }\n            // Add the special part\n            tokenList.add(token)\n            lastIndex \u003d range.last + 1\n        }\n\n        // Add any remaining plain text at the end of the message\n        if (lastIndex \u003c message.message.length) {\n            tokenList.add(TextToken(message.message.substring(lastIndex)))\n        }\n        tokenList\n    }\n\n    val currentUserDisplayName \u003d UserManager.currentUser?.displayName ?: \&quot;\&quot;\n    val isMentioned \u003d remember(message.message, currentUserDisplayName) {\n        if (currentUserDisplayName.isNotBlank()) {\n            \&quot;\\\\b@?${Regex.escape(currentUserDisplayName)}\\\\b\&quot;.toRegex(RegexOption.IGNORE_CASE).containsMatchIn(message.message)\n        } else {\n            false\n        }\n    }\n\n    val highlightColor \u003d when {\n        isDeleted -\u003e MaterialTheme.colorScheme.error.copy(alpha \u003d 0.2f)\n        isMentioned -\u003e MaterialTheme.colorScheme.primary.copy(alpha \u003d 0.2f) // A light blueish background for mentions.\n        message.type \u003d\u003d MessageType.SUBSCRIPTION -\u003e MaterialTheme.colorScheme.primary.copy(alpha \u003d 0.1f)\n        message.type \u003d\u003d MessageType.RAID -\u003e MaterialTheme.colorScheme.secondary.copy(alpha \u003d 0.1f)\n        message.type \u003d\u003d MessageType.ANNOUNCEMENT -\u003e MaterialTheme.colorScheme.tertiary.copy(alpha \u003d 0.1f)\n        message.type \u003d\u003d MessageType.SYSTEM -\u003e MaterialTheme.colorScheme.surfaceVariant.copy(alpha \u003d 0.4f)\n        else -\u003e Color.Transparent\n    }\n\n    val isLongClickEnabled \u003d message.author !\u003d null \u0026\u0026 message.author !\u003d UserManager.currentUser?.displayName\n    var offsetX by remember { mutableStateOf(0f) }\n    val swipeThreshold \u003d 150f\n    val scope \u003d rememberCoroutineScope()\n\n\n    Box(\n        modifier \u003d Modifier\n            .pointerInput(Unit) {\n                detectHorizontalDragGestures(\n                    onDragEnd \u003d {\n                        scope.launch {\n                            animate(initialValue \u003d offsetX, targetValue \u003d 0f) { value, _ -\u003e\n                                offsetX \u003d value\n                            }\n                        }\n                    }\n                ) { change, dragAmount -\u003e\n                    change.consume()\n                    val newOffsetX \u003d (offsetX + dragAmount).coerceIn(-swipeThreshold, swipeThreshold)\n                    if (kotlin.math.abs(newOffsetX) \u003e\u003d swipeThreshold) {\n                        onReply(message)\n                        offsetX \u003d 0f // Reset after triggering\n                    } else {\n                        offsetX \u003d newOffsetX\n                    }\n                }\n            }\n            .graphicsLayer(translationX \u003d offsetX)\n    ) {\n        if (kotlin.math.abs(offsetX) \u003e 0) {\n            Icon(\n                imageVector \u003d Icons.AutoMirrored.Filled.Reply,\n                contentDescription \u003d \&quot;Reply\&quot;,\n                modifier \u003d Modifier\n                    .align(if (offsetX \u003e 0) Alignment.CenterStart else Alignment.CenterEnd)\n                    .padding(horizontal \u003d 16.dp)\n                    .graphicsLayer(alpha \u003d (kotlin.math.abs(offsetX) / swipeThreshold).coerceIn(0f, 1f))\n            )\n        }\n        Column(\n            modifier \u003d Modifier\n                .fillMaxWidth()\n                .combinedClickable(\n                    enabled \u003d isLongClickEnabled,\n                    onClick \u003d {},\n                    onLongClick \u003d { showMenu \u003d true }\n                )\n                .background(highlightColor, shape \u003d MaterialTheme.shapes.small)\n                .padding(vertical \u003d 4.dp, horizontal \u003d 8.dp)\n        ) {\n            message.replyParentMsgBody?.let { parentMessageBody -\u003e\n                val parentAuthor \u003d message.replyParentUserLogin ?: \&quot;Unknown User\&quot;\n                Row(\n                    modifier \u003d Modifier.fillMaxWidth().padding(bottom \u003d 4.dp),\n                    verticalAlignment \u003d Alignment.CenterVertically\n                ) {\n                    Icon(Icons.AutoMirrored.Filled.Reply, contentDescription \u003d \&quot;Reply to\&quot;, modifier \u003d Modifier.size(14.dp), tint \u003d Color.Gray)\n                    Spacer(modifier \u003d Modifier.width(4.dp))\n                    Text(\n                        text \u003d \&quot;$parentAuthor: ${parentMessageBody.take(40)}${if (parentMessageBody.length \u003e 40) \&quot;...\&quot; else \&quot;\&quot;}\&quot;,\n                        style \u003d MaterialTheme.typography.bodySmall,\n                        color \u003d Color.Gray,\n                        maxLines \u003d 1\n                    )\n                }\n            }\n\n            Row(\n                verticalAlignment \u003d Alignment.Top,\n            ) {\n                // Timestamp\n                Text(\n                    text \u003d message.timestamp,\n                    color \u003d Color.Gray,\n                    fontSize \u003d 12.sp,\n                    modifier \u003d Modifier.padding(top \u003d 2.dp) // Align baseline a bit better\n                )\n                Spacer(Modifier.width(8.dp))\n\n                // Using FlowRow to handle line wrapping for the entire message content\n                FlowRow(\n                    horizontalArrangement \u003d Arrangement.spacedBy(4.dp),\n                    verticalArrangement \u003d Arrangement.spacedBy(4.dp),\n                    modifier \u003d Modifier.weight(1f)\n                ) {\n                    // System message icon\n                    when (message.type) {\n                        MessageType.SUBSCRIPTION -\u003e {\n                            Icon(\n                                imageVector \u003d Icons.Default.Star,\n                                contentDescription \u003d \&quot;Subscription\&quot;,\n                                tint \u003d MaterialTheme.colorScheme.primary,\n                                modifier \u003d Modifier\n                                    .size(18.dp)\n                                    .align(Alignment.CenterVertically)\n                            )\n                        }\n\n                        MessageType.RAID -\u003e {\n                            Icon(\n                                imageVector \u003d Icons.Default.People,\n                                contentDescription \u003d \&quot;Raid\&quot;,\n                                tint \u003d MaterialTheme.colorScheme.secondary,\n                                modifier \u003d Modifier\n                                    .size(18.dp)\n                                    .align(Alignment.CenterVertically)\n                            )\n                        }\n\n                        MessageType.ANNOUNCEMENT -\u003e {\n                            Icon(\n                                imageVector \u003d Icons.Default.Campaign,\n                                contentDescription \u003d \&quot;Announcement\&quot;,\n                                tint \u003d MaterialTheme.colorScheme.tertiary,\n                                modifier \u003d Modifier\n                                    .size(18.dp)\n                                    .align(Alignment.CenterVertically)\n                            )\n                        }\n                        MessageType.SYSTEM -\u003e {\n                            Icon(\n                                imageVector \u003d Icons.Default.Info,\n                                contentDescription \u003d \&quot;System Message\&quot;,\n                                tint \u003d MaterialTheme.colorScheme.onSurfaceVariant,\n                                modifier \u003d Modifier\n                                    .size(18.dp)\n                                    .align(Alignment.CenterVertically)\n                            )\n                        }\n\n                        else -\u003e {}\n                    }\n\n                    // Badges\n                    message.badges.forEach { badgeName -\u003e\n                        BadgeManager.getBadgeUrl(badgeName)?.let { url -\u003e\n                            AsyncImage(\n                                model \u003d url,\n                                contentDescription \u003d badgeName,\n                                modifier \u003d Modifier\n                                    .size(18.dp)\n                                    .align(Alignment.CenterVertically)\n                            )\n                        }\n                    }\n\n                    // Author\n                    if (message.author !\u003d null) {\n                        Text(\n                            text \u003d \&quot;${message.author}:\&quot;,\n                            fontWeight \u003d FontWeight.Bold,\n                            color \u003d authorColor,\n                            modifier \u003d Modifier\n                                .align(Alignment.CenterVertically),\n                            fontSize \u003d 14.sp\n                        )\n                    }\n\n                    // Render the tokenized message content\n                    tokens.forEach { token -\u003e\n                        when (token) {\n                            is TextToken -\u003e HighlightedTextToken(\n                                token \u003d token,\n                                isDeleted \u003d isDeleted,\n                                modifier \u003d Modifier.align(Alignment.CenterVertically)\n                            )\n\n                            is EmoteToken -\u003e AsyncImage(\n                                model \u003d token.url,\n                                contentDescription \u003d token.code,\n                                modifier \u003d Modifier\n                                    .size(24.dp) // Slightly larger emotes\n                                    .align(Alignment.CenterVertically)\n                            )\n\n                            is UrlToken -\u003e {\n                                val annotatedString \u003d buildAnnotatedString {\n                                    pushStringAnnotation(tag \u003d \&quot;URL\&quot;, annotation \u003d token.url)\n                                    withStyle(\n                                        style \u003d SpanStyle(\n                                            color \u003d MaterialTheme.colorScheme.primary,\n                                            textDecoration \u003d TextDecoration.Underline\n                                        )\n                                    ) {\n                                        append(token.url)\n                                    }\n                                    pop()\n                                }\n                                ClickableText(\n                                    text \u003d annotatedString,\n                                    modifier \u003d Modifier.align(Alignment.CenterVertically),\n                                    style \u003d LocalTextStyle.current.copy(fontSize \u003d 14.sp),\n                                    onClick \u003d { offset -\u003e\n                                        annotatedString\n                                            .getStringAnnotations(\n                                                tag \u003d \&quot;URL\&quot;,\n                                                start \u003d offset,\n                                                end \u003d offset\n                                            )\n                                            .firstOrNull()\n                                            ?.let { annotation -\u003e\n                                                uriHandler.openUri(annotation.item)\n                                            }\n                                    }\n                                )\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        DropdownMenu(\n            expanded \u003d showMenu,\n            onDismissRequest \u003d { showMenu \u003d false }\n        ) {\n            DropdownMenuItem(\n                text \u003d { Text(\&quot;Reply\&quot;) },\n                onClick \u003d {\n                    onReply(message)\n                    showMenu \u003d false\n                }\n            )\n            DropdownMenuItem(text \u003d { Text(\&quot;Profile\&quot;) }, onClick \u003d {\n                onShowProfile()\n                showMenu \u003d false\n            })\n            if (isCurrentUserModerator) {\n                DropdownMenuItem(text \u003d { Text(\&quot;Time out (10m)\&quot;) }, onClick \u003d {\n                    onTimeout()\n                    showMenu \u003d false\n                })\n                DropdownMenuItem(text \u003d { Text(\&quot;Ban\&quot;) }, onClick \u003d {\n                    onBan()\n                    showMenu \u003d false\n                })\n            }\n        }\n    }\n}\n\n\n@OptIn(ExperimentalMaterialApi::class)\n@Composable\nfun ChatterListScreen(\n    chatters: Map\u003cString, List\u003cString\u003e\u003e,\n    isLoading: Boolean,\n    onRefresh: () -\u003e Unit,\n    profileImageUrl: String,\n    displayName: String,\n    streamTitle: String?,\n    viewerCount: Int?\n) {\n    val pullRefreshState \u003d rememberPullRefreshState(refreshing \u003d isLoading, onRefresh \u003d onRefresh)\n\n    Box(Modifier.pullRefresh(pullRefreshState)) {\n        // Use a surface to ensure a background color from the theme is applied.\n        Surface(modifier \u003d Modifier.fillMaxSize()) {\n            if (isLoading \u0026\u0026 chatters.values.all { it.isEmpty() }) {\n                Box(modifier \u003d Modifier.fillMaxSize().padding(16.dp), contentAlignment \u003d Alignment.Center) {\n                    CircularProgressIndicator()\n                }\n            } else if (!isLoading \u0026\u0026 chatters.values.all { it.isEmpty() }) {\n                Box(modifier \u003d Modifier.fillMaxSize().padding(16.dp), contentAlignment \u003d Alignment.Center) {\n                    Text(\&quot;Could not load chatters or the chat is empty.\&quot;, textAlign \u003d TextAlign.Center)\n                }\n            } else {\n                LazyColumn(modifier \u003d Modifier.fillMaxSize()) {\n                    item {\n                        Column(\n                            modifier \u003d Modifier\n                                .fillMaxWidth()\n                                .padding(16.dp),\n                            horizontalAlignment \u003d Alignment.CenterHorizontally,\n                            verticalArrangement \u003d Arrangement.spacedBy(8.dp)\n                        ) {\n                            AsyncImage(\n                                model \u003d profileImageUrl,\n                                contentDescription \u003d \&quot;Streamer avatar\&quot;,\n                                modifier \u003d Modifier\n                                    .size(64.dp)\n                                    .clip(CircleShape)\n                            )\n                            Text(\n                                text \u003d displayName,\n                                style \u003d MaterialTheme.typography.titleLarge,\n                                fontWeight \u003d FontWeight.Bold\n                            )\n                            streamTitle?.let {\n                                Text(\n                                    text \u003d it,\n                                    style \u003d MaterialTheme.typography.bodyMedium,\n                                    textAlign \u003d TextAlign.Center\n                                )\n                            }\n                            viewerCount?.let {\n                                Text(\n                                    text \u003d \&quot;${formatViewerCount(it)} viewers\&quot;,\n                                    color \u003d Color.Red,\n                                    style \u003d MaterialTheme.typography.bodyMedium\n                                )\n                            }\n                        }\n                    }\n                    item { // Add a title to the bottom sheet\n                        Text(\n                            text \u003d \&quot;Chatters\&quot;,\n                            style \u003d MaterialTheme.typography.headlineSmall,\n                            modifier \u003d Modifier.padding(16.dp)\n                        )\n                    }\n                    chatters.forEach { (role, chatterList) -\u003e\n                        if (chatterList.isNotEmpty()) {\n                            item {\n                                Text(\n                                    text \u003d role,\n                                    style \u003d MaterialTheme.typography.titleMedium,\n                                    fontWeight \u003d FontWeight.Bold,\n                                    modifier \u003d Modifier.padding(vertical \u003d 8.dp, horizontal \u003d 16.dp)\n                                )\n                            }\n                            items(chatterList) { chatter -\u003e\n                                Row(\n                                    verticalAlignment \u003d Alignment.CenterVertically,\n                                    modifier \u003d Modifier.padding(vertical \u003d 4.dp, horizontal \u003d 16.dp)\n                                ) {\n                                    Icon(Icons.Default.Person, contentDescription \u003d role, modifier \u003d Modifier.size(16.dp))\n                                    Spacer(modifier \u003d Modifier.width(8.dp))\n                                    Text(chatter)\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        PullRefreshIndicator(\n            refreshing \u003d isLoading,\n            state \u003d pullRefreshState,\n            modifier \u003d Modifier.align(Alignment.TopCenter)\n        )\n    }\n}\n\n\n@Composable\nfun UserInfoDialog(\n    user: ChatMessage,\n    messages: List\u003cChatMessage\u003e,\n    onDismiss: () -\u003e Unit\n) {\n    AlertDialog(\n        onDismissRequest \u003d onDismiss,\n        title \u003d {\n            Row(verticalAlignment \u003d Alignment.CenterVertically) {\n                // You might want to fetch a higher-res profile image here if available\n                AsyncImage(\n                    model \u003d user.tags[\&quot;profile-image-url\&quot;], // Assuming you can get this from tags\n                    contentDescription \u003d \&quot;User Avatar\&quot;,\n                    modifier \u003d Modifier.size(40.dp).clip(CircleShape)\n                )\n                Spacer(modifier \u003d Modifier.width(8.dp))\n                Text(user.author ?: \&quot;Unknown User\&quot;)\n            }\n        },\n        text \u003d {\n            LazyColumn {\n                items(messages) { message -\u003e\n                    Row(verticalAlignment \u003d Alignment.CenterVertically) {\n                        Text(\n                            text \u003d message.timestamp,\n                            style \u003d MaterialTheme.typography.bodySmall,\n                            color \u003d Color.Gray,\n                            modifier \u003d Modifier.padding(end \u003d 8.dp)\n                        )\n                        Text(message.message, style \u003d MaterialTheme.typography.bodySmall)\n                    }\n                    Spacer(modifier \u003d Modifier.height(4.dp))\n                }\n            }\n        },\n        confirmButton \u003d {\n            TextButton(onClick \u003d onDismiss) {\n                Text(\&quot;Close\&quot;)\n            }\n        }\n    )\n}\n\n@Composable\nfun PollCard(poll: Poll, onVote: (String, String) -\u003e Unit) {\n    Card(\n        modifier \u003d Modifier\n            .fillMaxWidth()\n            .padding(8.dp),\n        elevation \u003d CardDefaults.cardElevation(defaultElevation \u003d 4.dp)\n    ) {\n        Column(modifier \u003d Modifier.padding(16.dp)) {\n            Text(text \u003d poll.title, style \u003d MaterialTheme.typography.titleMedium, fontWeight \u003d FontWeight.Bold)\n            Spacer(modifier \u003d Modifier.height(16.dp))\n\n            poll.choices.forEach {\n                PollChoiceItem(choice \u003d it, totalVotes \u003d poll.totalVotes, onVote \u003d {\n                    onVote(poll.id, it.id)\n                })\n                Spacer(modifier \u003d Modifier.height(8.dp))\n            }\n\n            if (poll.status \u003d\u003d \&quot;COMPLETED\&quot;) {\n                Text(\&quot;Poll has ended\&quot;, style \u003d MaterialTheme.typography.bodySmall, color \u003d Color.Gray)\n            }\n        }\n    }\n}\n\n@Composable\nfun PollChoiceItem(choice: PollChoice, totalVotes: Int, onVote: () -\u003e Unit) {\n    val percentage \u003d if (totalVotes \u003e 0) choice.votes.toFloat() / totalVotes else 0f\n    val animatedPercentage by animateFloatAsState(targetValue \u003d percentage, label \u003d \&quot;\&quot;)\n\n    Column(modifier \u003d Modifier.clickable(onClick \u003d onVote)) {\n        Row(verticalAlignment \u003d Alignment.CenterVertically) {\n            Text(text \u003d choice.title, modifier \u003d Modifier.weight(1f))\n            Text(text \u003d \&quot;${(animatedPercentage * 100).toInt()}%\&quot;, fontWeight \u003d FontWeight.Bold)\n        }\n        Spacer(modifier \u003d Modifier.height(4.dp))\n        LinearProgressIndicator(\n            progress \u003d { animatedPercentage },\n            modifier \u003d Modifier.fillMaxWidth()\n        )\n    }\n}\n\n@Composable\nfun ChatInputBar(\n    text: TextFieldValue,\n    onTextChanged: (TextFieldValue) -\u003e Unit,\n    onSendClick: () -\u003e Unit,\n    onEmoteClick: () -\u003e Unit\n) {\n    Row(\n        modifier \u003d Modifier\n            .fillMaxWidth()\n            .padding(8.dp)\n            .height(IntrinsicSize.Min),\n        verticalAlignment \u003d Alignment.CenterVertically\n    ) {\n        OutlinedTextField(\n            value \u003d text,\n            onValueChange \u003d onTextChanged,\n            modifier \u003d Modifier.weight(1f),\n            placeholder \u003d { Text(\&quot;Send a message\&quot;) },\n            singleLine \u003d true,\n            keyboardOptions \u003d KeyboardOptions.Default.copy(\n                capitalization \u003d KeyboardCapitalization.Sentences,\n                imeAction \u003d ImeAction.Send\n            ),\n            keyboardActions \u003d KeyboardActions(\n                onSend \u003d {\n                    if (text.text.isNotBlank()) {\n                        onSendClick()\n                    }\n                }\n            ),\n            leadingIcon \u003d {\n                IconButton(onClick \u003d onEmoteClick) {\n                    Icon(Icons.Filled.Mood, contentDescription \u003d \&quot;Open emote menu\&quot;)\n                }\n            }\n        )\n\n        Spacer(modifier \u003d Modifier.width(8.dp))\n\n        Surface(\n            shape \u003d CircleShape,\n            color \u003d if (text.text.isNotBlank()) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface.copy(\n                alpha \u003d 0.12f\n            ),\n            modifier \u003d Modifier\n                .fillMaxHeight()\n                .aspectRatio(1f)\n                .clickable(enabled \u003d text.text.isNotBlank(), onClick \u003d onSendClick)\n        ) {\n            Box(contentAlignment \u003d Alignment.Center, modifier \u003d Modifier.fillMaxSize()) {\n                Icon(\n                    imageVector \u003d Icons.AutoMirrored.Filled.Send,\n                    contentDescription \u003d \&quot;Send\&quot;,\n                    tint \u003d if (text.text.isNotBlank()) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSurface.copy(\n                        alpha \u003d 0.38f\n                    )\n                )\n            }\n        }\n    }\n}\n\nprivate fun formatViewerCount(count: Int): String {\n    return when {\n        count \u003e\u003d 1_000_000 -\u003e String.format(\&quot;%.1fM\&quot;, count / 1_000_000f)\n        count \u003e\u003d 1_000 -\u003e String.format(\&quot;%.1fK\&quot;, count / 1_000f)\n        else -\u003e count.toString()\n    }\n}\n\n```\n\u003c/file_contents\u003e\n\n\n\u003cfile_contents\u003e\n```kotlin:app/src/main/java/com/norwedish/twitchchatapp/ChatViewModel.kt, lines\u003dALL(1-541)\npackage com.norwedish.twitchchatapp\n\nimport android.util.Log\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.SpanStyle\nimport androidx.compose.ui.text.TextRange\nimport androidx.compose.ui.text.buildAnnotatedString\nimport androidx.compose.ui.text.input.TextFieldValue\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport java.time.Instant\nimport java.time.temporal.ChronoUnit\nimport java.util.Collections\nimport java.util.UUID\n\nclass ChatViewModel : ViewModel() {\n\n    private val _messages \u003d MutableStateFlow\u003cList\u003cChatMessage\u003e\u003e(emptyList())\n    val messages: StateFlow\u003cList\u003cChatMessage\u003e\u003e \u003d _messages.asStateFlow()\n\n    private val _connectionState \u003d MutableStateFlow(ConnectionState.DISCONNECTED)\n    val connectionState: StateFlow\u003cConnectionState\u003e \u003d _connectionState.asStateFlow()\n\n    private val _inputMessage \u003d MutableStateFlow(TextFieldValue(\&quot;\&quot;))\n    val inputMessage: StateFlow\u003cTextFieldValue\u003e \u003d _inputMessage.asStateFlow()\n\n    private val _isEmoteMenuVisible \u003d MutableStateFlow(false)\n    val isEmoteMenuVisible: StateFlow\u003cBoolean\u003e \u003d _isEmoteMenuVisible.asStateFlow()\n\n    private val _availableEmotes \u003d MutableStateFlow\u003cList\u003cEmote\u003e\u003e(emptyList())\n    val availableEmotes: StateFlow\u003cList\u003cEmote\u003e\u003e \u003d _availableEmotes.asStateFlow()\n\n    private val _isCurrentUserModerator \u003d MutableStateFlow(false)\n    val isCurrentUserModerator: StateFlow\u003cBoolean\u003e \u003d _isCurrentUserModerator.asStateFlow()\n\n    private val _selectedUserForProfile \u003d MutableStateFlow\u003cChatMessage?\u003e(null)\n    val selectedUserForProfile: StateFlow\u003cChatMessage?\u003e \u003d _selectedUserForProfile.asStateFlow()\n\n    private val _viewerCount \u003d MutableStateFlow\u003cInt?\u003e(null)\n    val viewerCount: StateFlow\u003cInt?\u003e \u003d _viewerCount.asStateFlow()\n\n    private val _streamTitle \u003d MutableStateFlow\u003cString?\u003e(null)\n    val streamTitle: StateFlow\u003cString?\u003e \u003d _streamTitle.asStateFlow()\n\n    private val _poll \u003d MutableStateFlow\u003cPoll?\u003e(null)\n    val poll: StateFlow\u003cPoll?\u003e \u003d _poll.asStateFlow()\n\n    private val _isChatterListVisible \u003d MutableStateFlow(false)\n    val isChatterListVisible: StateFlow\u003cBoolean\u003e \u003d _isChatterListVisible.asStateFlow()\n\n    private val _isChattersLoading \u003d MutableStateFlow(false)\n    val isChattersLoading: StateFlow\u003cBoolean\u003e \u003d _isChattersLoading.asStateFlow()\n\n    private val _chatters \u003d MutableStateFlow\u003cMap\u003cString, List\u003cString\u003e\u003e\u003e(emptyMap())\n    val chatters: StateFlow\u003cMap\u003cString, List\u003cString\u003e\u003e\u003e \u003d _chatters.asStateFlow()\n\n    private val _userSuggestions \u003d MutableStateFlow\u003cList\u003cString\u003e\u003e(emptyList())\n    val userSuggestions: StateFlow\u003cList\u003cString\u003e\u003e \u003d _userSuggestions.asStateFlow()\n\n    private val _showUserSuggestions \u003d MutableStateFlow(false)\n    val showUserSuggestions: StateFlow\u003cBoolean\u003e \u003d _showUserSuggestions.asStateFlow()\n\n    private val _currentMessageCount \u003d MutableStateFlow(0)\n    val currentMessageCount: StateFlow\u003cInt\u003e \u003d _currentMessageCount.asStateFlow()\n\n    private val _roomState \u003d MutableStateFlow\u003cRoomState?\u003e(null)\n    val roomState: StateFlow\u003cRoomState?\u003e \u003d _roomState.asStateFlow()\n\n    private val _replyToMessage \u003d MutableStateFlow\u003cChatMessage?\u003e(null)\n    val replyToMessage: StateFlow\u003cChatMessage?\u003e \u003d _replyToMessage.asStateFlow()\n\n    private val _followRelationship \u003d MutableStateFlow\u003cFollowedChannel?\u003e(null)\n    val followRelationship: StateFlow\u003cFollowedChannel?\u003e \u003d _followRelationship.asStateFlow()\n\n    private val _unreadMessageCount \u003d MutableStateFlow(0)\n    val unreadMessageCount: StateFlow\u003cInt\u003e \u003d _unreadMessageCount.asStateFlow()\n\n    private val _scrollToBottom \u003d MutableSharedFlow\u003cUnit\u003e(replay \u003d 0)\n    val scrollToBottom \u003d _scrollToBottom.asSharedFlow()\n\n    // Properties for the local player\n    private val _isLocalPlayerVisible \u003d MutableStateFlow(false)\n    val isLocalPlayerVisible: StateFlow\u003cBoolean\u003e \u003d _isLocalPlayerVisible.asStateFlow()\n\n    private val _localStreamUrl \u003d MutableStateFlow\u003cString?\u003e(null)\n    val localStreamUrl: StateFlow\u003cString?\u003e \u003d _localStreamUrl.asStateFlow()\n\n    private var currentChannelId: String \u003d \&quot;\&quot;\n    private var currentChannel: String \u003d \&quot;\&quot;\n    private var pollingJob: Job? \u003d null\n    private var chatService: ChatService? \u003d null\n    private var messageCollectionJob: Job? \u003d null\n    private var messageProcessingJob: Job? \u003d null\n    private var stateCollectionJob: Job? \u003d null\n    private var pollCollectionJob: Job? \u003d null\n    private var modStatusCollectionJob: Job? \u003d null\n    private var deletedMessagesJob: Job? \u003d null\n    private var deletedUserMessagesJob: Job? \u003d null\n    private var roomStateCollectionJob: Job? \u003d null\n    private val messageBuffer \u003d Collections.synchronizedList(mutableListOf\u003cChatMessage\u003e())\n    private var isUserAtBottom \u003d true\n\n    override fun onCleared() {\n        super.onCleared()\n        stopPolling()\n        messageProcessingJob?.cancel()\n    }\n\n    fun onScrollStateChanged(isAtBottom: Boolean) {\n        isUserAtBottom \u003d isAtBottom\n        if (isUserAtBottom) {\n            _unreadMessageCount.value \u003d 0\n        }\n    }\n\n    fun jumpToBottom() {\n        viewModelScope.launch {\n            _scrollToBottom.emit(Unit)\n        }\n        _unreadMessageCount.value \u003d 0\n        isUserAtBottom \u003d true\n    }\n\n    fun setChatService(service: ChatService) {\n        chatService \u003d service\n        // Cancel all previous jobs\n        messageCollectionJob?.cancel()\n        stateCollectionJob?.cancel()\n        pollCollectionJob?.cancel()\n        modStatusCollectionJob?.cancel()\n        deletedMessagesJob?.cancel()\n        deletedUserMessagesJob?.cancel()\n        messageProcessingJob?.cancel()\n        roomStateCollectionJob?.cancel()\n        messageBuffer.clear()\n        _currentMessageCount.value \u003d 0 // Reset message count when service is set\n\n        messageCollectionJob \u003d viewModelScope.launch {\n            service.chatMessages.collect { chatMessage -\u003e\n                messageBuffer.add(chatMessage)\n                if (chatMessage.author.equals(UserManager.currentUser?.login, ignoreCase \u003d true)) {\n                    if (chatMessage.authorColor !\u003d null \u0026\u0026 chatMessage.authorColor !\u003d UserManager.currentUser?.chatColor) {\n                        UserManager.updateUserChatColor(chatMessage.authorColor)\n                    }\n                }\n            }\n        }\n\n        messageProcessingJob \u003d viewModelScope.launch {\n            while (true) {\n                delay(500) // Update every half second\n                if (messageBuffer.isNotEmpty()) {\n                    val messagesToAdd \u003d synchronized(messageBuffer) {\n                        val bufferCopy \u003d ArrayList(messageBuffer)\n                        messageBuffer.clear()\n                        bufferCopy\n                    }\n                    if (!isUserAtBottom) {\n                        _unreadMessageCount.value +\u003d messagesToAdd.size\n                    }\n\n                    _messages.update { currentList -\u003e\n                        val newList \u003d (currentList + messagesToAdd).takeLast(200)\n                        _currentMessageCount.value \u003d newList.size // Update the displayed message count\n                        newList\n                    }\n                }\n            }\n        }\n\n        stateCollectionJob \u003d viewModelScope.launch {\n            service.connectionState.collect { state -\u003e\n                _connectionState.value \u003d state\n            }\n        }\n        pollCollectionJob \u003d viewModelScope.launch {\n            service.poll.collect { poll -\u003e\n                _poll.value \u003d poll\n            }\n        }\n        modStatusCollectionJob \u003d viewModelScope.launch {\n            service.isCurrentUserModerator.collect { isMod -\u003e\n                _isCurrentUserModerator.value \u003d isMod\n            }\n        }\n        roomStateCollectionJob \u003d viewModelScope.launch {\n            service.roomState.collect { roomState -\u003e\n                _roomState.value \u003d roomState\n            }\n        }\n\n        deletedMessagesJob \u003d viewModelScope.launch {\n            service.deletedMessageIds.collect { deletedId -\u003e\n                _messages.update { currentMessages -\u003e\n                    val newList \u003d currentMessages.map {\n                        if (it.tags[\&quot;id\&quot;] \u003d\u003d deletedId) {\n                            it.copy(type \u003d MessageType.DELETED)\n                        } else {\n                            it\n                        }\n                    }\n                    _currentMessageCount.value \u003d newList.size // Update count on deletion\n                    newList\n                }\n            }\n        }\n\n        deletedUserMessagesJob \u003d viewModelScope.launch {\n            service.deletedUserMessages.collect { deletedAuthor -\u003e\n                _messages.update { currentMessages -\u003e\n                    val newList \u003d currentMessages.map {\n                        if (it.authorLogin.equals(deletedAuthor, ignoreCase \u003d true)) {\n                            it.copy(type \u003d MessageType.DELETED)\n                        } else {\n                            it\n                        }\n                    }\n                    _currentMessageCount.value \u003d newList.size // Update count on deletion\n                    newList\n                }\n            }\n        }\n\n        viewModelScope.launch {\n            service.chatters.collect {\n                fetchChatters()\n            }\n        }\n    }\n\n    private fun fetchFollowRelationship() {\n        viewModelScope.launch {\n            val user \u003d UserManager.currentUser\n            val token \u003d UserManager.accessToken\n            if (user !\u003d null \u0026\u0026 token !\u003d null) {\n                _followRelationship.value \u003d TwitchApi.getFollowRelationship(user.id, currentChannelId, token, UserManager.CLIENT_ID)\n            }\n        }\n    }\n\n    fun onChatterListRequested() {\n        _isChatterListVisible.value \u003d true\n        fetchChatters()\n    }\n\n    fun onChatterListDismissed() {\n        _isChatterListVisible.value \u003d false\n    }\n\n    fun fetchChatters() {\n        viewModelScope.launch {\n            _isChattersLoading.value \u003d true\n            val currentUser \u003d UserManager.currentUser\n            val token \u003d UserManager.accessToken\n\n            if (currentUser !\u003d null \u0026\u0026 token !\u003d null) {\n                val helixChatters \u003d TwitchApi.getHelixChatters(currentChannelId, currentUser.id, token, UserManager.CLIENT_ID)\n\n                if (helixChatters !\u003d null) {\n                    val grouped \u003d mutableMapOf\u003cString, MutableList\u003cString\u003e\u003e(\n                        \&quot;Viewers\&quot; to mutableListOf()\n                    )\n\n                    helixChatters.forEach { chatter -\u003e\n                        grouped[\&quot;Viewers\&quot;]?.add(chatter.userName)\n                    }\n                    grouped.forEach { (_, list) -\u003e list.sortWith(String.CASE_INSENSITIVE_ORDER) }\n                    _chatters.value \u003d grouped\n                } else {\n                    // Non-Moderator Path: Best-effort categorization\n                    chatService?.let { service -\u003e\n                        val viewers \u003d service.chatters.value\n                        val grouped \u003d mutableMapOf\u003cString, MutableList\u003cString\u003e\u003e(\n                            \&quot;Viewers\&quot; to mutableListOf()\n                        )\n\n                        viewers.forEach { viewer -\u003e\n                            grouped[\&quot;Viewers\&quot;]?.add(viewer)\n                        }\n                        grouped.forEach { (_, list) -\u003e list.sortWith(String.CASE_INSENSITIVE_ORDER) }\n                        _chatters.value \u003d grouped\n                    }\n                }\n            }\n            _isChattersLoading.value \u003d false\n        }\n    }\n\n    private fun startPolling(userId: String) {\n        stopPolling()\n        pollingJob \u003d viewModelScope.launch {\n            while (true) {\n                UserManager.accessToken?.let { token -\u003e\n                    val stream \u003d TwitchApi.getStream(userId, token, UserManager.CLIENT_ID)\n                    _viewerCount.value \u003d stream?.viewerCount\n                    _streamTitle.value \u003d stream?.title\n                }\n                delay(60_000)\n            }\n        }\n    }\n\n    private fun stopPolling() {\n        pollingJob?.cancel()\n        pollingJob \u003d null\n    }\n\n    fun onShowUserProfile(message: ChatMessage) {\n        _selectedUserForProfile.value \u003d message\n    }\n\n    fun onDismissUserProfile() {\n        _selectedUserForProfile.value \u003d null\n    }\n\n    fun onTimeout(username: String) {\n        modAction(\&quot;timeout\&quot;, username)\n    }\n\n    fun onBan(username: String) {\n        modAction(\&quot;ban\&quot;, username)\n    }\n\n    fun onReply(message: ChatMessage) {\n        _replyToMessage.value \u003d message\n        _inputMessage.update { currentTFV -\u003e\n            val currentText \u003d currentTFV.text\n            val newMention \u003d \&quot;@${message.authorLogin ?: message.author ?: \&quot;\&quot;} \&quot;\n            val mentionRegex \u003d Regex(\&quot;\&quot;\&quot;^@\\w+\\s\&quot;\&quot;\&quot;)\n            val newText \u003d if (mentionRegex.containsMatchIn(currentText)) {\n                currentText.replaceFirst(mentionRegex, newMention)\n            } else {\n                \&quot;$newMention$currentText\&quot;\n            }\n            TextFieldValue(newText, TextRange(newText.length))\n        }\n    }\n\n    fun clearReply() {\n        _replyToMessage.value \u003d null\n        _inputMessage.update { currentTFV -\u003e\n            val currentText \u003d currentTFV.text\n            val mentionRegex \u003d Regex(\&quot;\&quot;\&quot;^@\\w+\\s\&quot;\&quot;\&quot;)\n            val newText \u003d if (mentionRegex.containsMatchIn(currentText)) {\n                currentText.replaceFirst(mentionRegex, \&quot;\&quot;)\n            } else {\n                currentText\n            }\n            TextFieldValue(newText, TextRange(newText.length))\n        }\n    }\n\n    fun voteOnPoll(pollId: String, choiceId: String) {\n        chatService?.voteOnPoll(pollId, choiceId)\n    }\n\n    private fun modAction(action: String, username: String) {\n        val command \u003d when (action) {\n            \&quot;ban\&quot; -\u003e \&quot;/ban $username\&quot;\n            \&quot;timeout\&quot; -\u003e \&quot;/timeout $username 600\&quot;\n            else -\u003e return\n        }\n        chatService?.sendMessage(currentChannel, command)\n    }\n\n    fun onInputChanged(newValue: TextFieldValue) {\n        _inputMessage.value \u003d newValue\n        val text \u003d newValue.text\n        val cursorPosition \u003d newValue.selection.start\n        val lastAt \u003d text.substring(0, cursorPosition).lastIndexOf(\u0027@\u0027)\n\n        if (lastAt !\u003d -1) {\n            val query \u003d text.substring(lastAt + 1, cursorPosition)\n            if (\&quot; \&quot; !in query) {\n                val allChatters \u003d _chatters.value.values.flatten().distinct()\n                _userSuggestions.value \u003d allChatters.filter { it.startsWith(query, ignoreCase \u003d true) }\n                _showUserSuggestions.value \u003d _userSuggestions.value.isNotEmpty()\n            } else {\n                _showUserSuggestions.value \u003d false\n            }\n        } else {\n            _showUserSuggestions.value \u003d false\n        }\n\n        // Add syntax highlighting for mentions\n        val annotatedString \u003d buildAnnotatedString {\n            append(text)\n            val userMentionRegex \u003d Regex(\&quot;\&quot;\&quot;@\\w+\&quot;\&quot;\&quot;)\n            userMentionRegex.findAll(text).forEach { matchResult -\u003e\n                val user \u003d matchResult.value.drop(1)\n                val allChatters \u003d _chatters.value.values.flatten().distinct()\n                if (allChatters.any { it.equals(user, ignoreCase \u003d true) }) {\n                    addStyle(\n                        style \u003d SpanStyle(\n                            color \u003d Color.White,\n                            background \u003d Color.Black\n                        ),\n                        start \u003d matchResult.range.first,\n                        end \u003d matchResult.range.last + 1\n                    )\n                }\n            }\n        }\n        _inputMessage.value \u003d TextFieldValue(annotatedString, newValue.selection)\n    }\n\n    fun onUserSuggestionSelected(username: String) {\n        val currentTFV \u003d _inputMessage.value\n        val currentText \u003d currentTFV.text\n        val cursorPosition \u003d currentTFV.selection.start\n\n        val startOfMention \u003d currentText.substring(0, cursorPosition).lastIndexOf(\u0027@\u0027)\n        if (startOfMention \u003d\u003d -1) {\n            _showUserSuggestions.value \u003d false\n            return\n        }\n\n        val mentionQuery \u003d currentText.substring(startOfMention + 1, cursorPosition)\n        if (mentionQuery.contains(\&quot; \&quot;)) {\n            _showUserSuggestions.value \u003d false\n            return\n        }\n\n        val prefix \u003d currentText.substring(0, startOfMention)\n\n        var endOfMention \u003d cursorPosition\n        while (endOfMention \u003c currentText.length \u0026\u0026 currentText[endOfMention] !\u003d \u0027 \u0027) {\n            endOfMention++\n        }\n        val suffix \u003d currentText.substring(endOfMention)\n\n        val newText \u003d buildString {\n            append(prefix)\n            append(\u0027@\u0027)\n            append(username)\n            if (suffix.isEmpty() || !suffix.startsWith(\&quot; \&quot;)) {\n                append(\&quot; \&quot;)\n            }\n            append(suffix)\n        }\n\n        val newCursorPosition \u003d prefix.length + 1 + username.length + 1\n\n        val annotatedString \u003d buildAnnotatedString {\n            append(newText)\n            val userMentionRegex \u003d Regex(\&quot;\&quot;\&quot;@\\w+\&quot;\&quot;\&quot;)\n            userMentionRegex.findAll(newText).forEach { matchResult -\u003e\n                val user \u003d matchResult.value.drop(1)\n                val allChatters \u003d _chatters.value.values.flatten().distinct()\n                if (allChatters.any { it.equals(user, ignoreCase \u003d true) }) {\n                    addStyle(\n                        style \u003d SpanStyle(\n                            color \u003d Color.White,\n                            background \u003d Color.Black\n                        ),\n                        start \u003d matchResult.range.first,\n                        end \u003d matchResult.range.last + 1\n                    )\n                }\n            }\n        }\n\n        _inputMessage.value \u003d TextFieldValue(annotatedString, TextRange(newCursorPosition))\n        _showUserSuggestions.value \u003d false\n    }\n\n    fun onEmoteMenuToggled() {\n        if (!_isEmoteMenuVisible.value) {\n            _availableEmotes.value \u003d EmoteManager.getAllEmotes()\n        }\n        _isEmoteMenuVisible.value \u003d !_isEmoteMenuVisible.value\n    }\n\n    fun onEmoteSelected(emoteCode: String) {\n        _inputMessage.update { currentFieldValue -\u003e\n            val currentText \u003d currentFieldValue.text\n            val newText \u003d if (currentText.isBlank()) {\n                emoteCode\n            } else {\n                \&quot;$currentText $emoteCode \&quot;\n            }\n            TextFieldValue(newText, TextRange(newText.length))\n        }\n        onEmoteMenuToggled()\n    }\n\n    fun sendMessage() {\n        val messageText \u003d _inputMessage.value.text\n        if (messageText.isBlank()) return\n        val currentUser \u003d UserManager.currentUser ?: return\n\n        val messageId \u003d UUID.randomUUID().toString()\n\n        val localMessage \u003d ChatMessage(\n            id \u003d messageId,\n            author \u003d currentUser.displayName,\n            authorLogin \u003d currentUser.login,\n            message \u003d messageText,\n            authorColor \u003d currentUser.chatColor ?: \&quot;#8A2BE2\&quot;,\n            emotes \u003d EmoteManager.parseThirdPartyEmotes(messageText),\n            badges \u003d emptyList(),\n            replyParentMsgId \u003d _replyToMessage.value?.tags?.get(\&quot;id\&quot;),\n            replyParentUserLogin \u003d _replyToMessage.value?.authorLogin ?: _replyToMessage.value?.author,\n            replyParentMsgBody \u003d _replyToMessage.value?.message\n        )\n        _messages.update { currentList -\u003e\n            val newList \u003d (currentList + localMessage).takeLast(200)\n            _currentMessageCount.value \u003d newList.size // Update the displayed message count\n            newList\n        }\n\n        chatService?.sendMessage(currentChannel, messageText, _replyToMessage.value?.tags?.get(\&quot;id\&quot;))\n\n        _inputMessage.value \u003d TextFieldValue(\&quot;\&quot;)\n        _replyToMessage.value \u003d null // Clear reply after sending\n    }\n\n    fun prepareForChannel(channelName: String, twitchUserId: String) {\n        this.currentChannel \u003d channelName\n        this.currentChannelId \u003d twitchUserId\n        _messages.value \u003d emptyList()\n        _currentMessageCount.value \u003d 0 // Reset message count when preparing for a new channel\n        startPolling(twitchUserId)\n        fetchFollowRelationship()\n        viewModelScope.launch {\n            UserManager.accessToken?.let { token -\u003e\n                BadgeManager.loadGlobalBadges(token, UserManager.CLIENT_ID)\n                EmoteManager.loadEmotesForChannel(twitchUserId, token, UserManager.CLIENT_ID)\n            }\n        }\n    }\n}\n```\n\u003c/file_contents\u003e\n\n\u003c/attached_files\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nWhen i scroll up i would like to have small button with a downwards arrow and text that contains \&quot;${amount} new messages\&quot; when there are new messages that i haven\u0027t seen yet. The button and text has to be on the down side just above the input bar and small bar with the chat status text. I want to see this message only when i manually scrolled to another place in the chat otherwise i want it autoscroll\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[]}]},&quot;41817e87-d9fa-460b-b34f-da68e2b48874&quot;:{&quot;id&quot;:&quot;41817e87-d9fa-460b-b34f-da68e2b48874&quot;,&quot;name&quot;:&quot;New Chat&quot;,&quot;timestamp&quot;:1764502267909,&quot;messages&quot;:[]}}" />
  </component>
</project>