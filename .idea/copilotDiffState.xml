<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/WHISPER_ENHANCEMENTS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/WHISPER_ENHANCEMENTS.md" />
              <option name="updatedContent" value="# Whisper System Enhancements&#10;&#10;## Features Added&#10;&#10;### 1. Search Bar in Whisper Screen ✅&#10;- **Location**: WhisperScreen.kt - WhisperConversationList composable&#10;- **Functionality**: &#10;  - Search for users in your direct message conversations&#10;  - Real-time filtering by username or display name&#10;  - Clear button to quickly reset the search&#10;  - Shows &quot;No users found&quot; when search returns no results&#10;&#10;**Implementation Details:**&#10;- Uses `OutlinedTextField` with search icon and clear button&#10;- Filters conversations based on both `otherDisplayName` and `otherUserLogin`&#10;- Case-insensitive search&#10;- Maintains list display while searching&#10;&#10;### 2. Send Whisper Button in User Profile Dialog ✅&#10;- **Location**: ChatScreen.kt - UserInfoDialog composable&#10;- **Functionality**:&#10;  - Opens user profile by clicking on their message&#10;  - Shows their message history&#10;  - NEW: &quot;Send Whisper&quot; button to directly message the user&#10;  - &quot;Close&quot; button to dismiss the dialog&#10;&#10;**Implementation Details:**&#10;- Updated `UserInfoDialog` function signature to accept `onSendWhisper` callback&#10;- Added `Button` for &quot;Send Whisper&quot; and moved &quot;Close&quot; to `dismissButton`&#10;- When clicked, automatically:&#10;  - Starts a new conversation with the user&#10;  - Switches to the full whisper screen&#10;  - Pre-fills user information (login, display name, profile image)&#10;  - Closes the user profile dialog&#10;&#10;### 3. Start New Conversation Method in WhisperViewModel ✅&#10;- **Location**: WhisperViewModel.kt&#10;- **Method**: `startNewConversation(userLogin: String, displayName: String, profileImageUrl: String)`&#10;- **Functionality**:&#10;  - Creates a new conversation entry if it doesn't exist&#10;  - Automatically selects the conversation for display&#10;  - Can be called from anywhere in the app with user information&#10;&#10;**Implementation Details:**&#10;- Checks if conversation already exists to avoid duplicates&#10;- Creates empty conversation object if new&#10;- Saves conversation to preferences&#10;- Automatically loads all conversations and selects the new one&#10;- Used by the &quot;Send Whisper&quot; button in user profiles&#10;&#10;## User Flow&#10;&#10;### Sending Whisper to Someone from Chat:&#10;1. User clicks on a message in the chat&#10;2. User profile dialog opens showing message history&#10;3. User clicks &quot;Send Whisper&quot; button&#10;4. New conversation created (if doesn't exist)&#10;5. Full whisper screen opens with the selected user&#10;6. User can now type and send messages&#10;&#10;### Using Search in Whisper Screen:&#10;1. User opens Whisper Screen from chat&#10;2. Sees search bar at top of conversation list&#10;3. Types user name or login to filter conversations&#10;4. Results update in real-time&#10;5. Clicks on desired user to start/continue conversation&#10;6. Conversation selected and message detail view shown&#10;&#10;## Files Modified&#10;&#10;1. **WhisperScreen.kt**&#10;   - Added Search icon import&#10;   - Updated `WhisperConversationList` with search functionality&#10;&#10;2. **ChatScreen.kt**&#10;   - Updated `UserInfoDialog` function signature&#10;   - Added &quot;Send Whisper&quot; button&#10;   - Connected button to whisper system&#10;&#10;3. **WhisperViewModel.kt**&#10;   - Added `startNewConversation()` method&#10;   - Handles conversation creation and selection&#10;&#10;## Integration Points&#10;&#10;- Whisper widget already exists in ChatScreen&#10;- Full whisper screen navigation already implemented&#10;- PreferenceManager handles conversation persistence&#10;- WhisperService handles message sending&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/CastButton.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/CastButton.kt" />
              <option name="originalContent" value="package com.norwedish.twitchchatapp&#10;&#10;import android.content.Context&#10;import android.view.View&#10;import android.widget.ImageButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import com.google.android.gms.cast.framework.CastButtonFactory&#10;&#10;@Composable&#10;fun CastButton(modifier: Modifier = Modifier, onFallback: () -&gt; Unit = {}) {&#10;    AndroidView&lt;View&gt;(factory = { context: Context -&gt;&#10;        try {&#10;            val mrButton = androidx.mediarouter.app.MediaRouteButton(context)&#10;            try {&#10;                CastButtonFactory.setUpMediaRouteButton(context.applicationContext, mrButton)&#10;            } catch (_: Exception) {&#10;                // ignore setup; button will still open system chooser in many cases&#10;            }&#10;            mrButton&#10;        } catch (_: Throwable) {&#10;            // Fallback: create a simple ImageButton that triggers onFallback&#10;            ImageButton(context).apply {&#10;                setOnClickListener { onFallback() }&#10;                setImageResource(android.R.drawable.ic_menu_share)&#10;                contentDescription = &quot;Cast&quot;&#10;            }&#10;        }&#10;    }, modifier = modifier)&#10;}&#10;" />
              <option name="updatedContent" value="package com.norwedish.twitchchatapp&#13;&#10;&#13;&#10;/**&#13;&#10; * A small composable that shows the Cast button and handles opening the Cast dialog when available.&#13;&#10; */&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.view.View&#13;&#10;import android.widget.ImageButton&#13;&#10;import androidx.compose.runtime.Composable&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.viewinterop.AndroidView&#13;&#10;import com.google.android.gms.cast.framework.CastButtonFactory&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun CastButton(modifier: Modifier = Modifier, onFallback: () -&gt; Unit = {}) {&#13;&#10;    AndroidView&lt;View&gt;(factory = { context: Context -&gt;&#13;&#10;        try {&#13;&#10;            val mrButton = androidx.mediarouter.app.MediaRouteButton(context)&#13;&#10;            try {&#13;&#10;                CastButtonFactory.setUpMediaRouteButton(context.applicationContext, mrButton)&#13;&#10;            } catch (_: Exception) {&#13;&#10;                // ignore setup; button will still open system chooser in many cases&#13;&#10;            }&#13;&#10;            mrButton&#13;&#10;        } catch (_: Throwable) {&#13;&#10;            // Fallback: create a simple ImageButton that triggers onFallback&#13;&#10;            ImageButton(context).apply {&#13;&#10;                setOnClickListener { onFallback() }&#13;&#10;                setImageResource(android.R.drawable.ic_menu_share)&#13;&#10;                contentDescription = &quot;Cast&quot;&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }, modifier = modifier)&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/CastOptionsProvider.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/CastOptionsProvider.kt" />
              <option name="originalContent" value="package com.norwedish.twitchchatapp&#10;&#10;import android.content.Context&#10;import com.google.android.gms.cast.framework.CastOptions&#10;import com.google.android.gms.cast.framework.OptionsProvider&#10;import com.google.android.gms.cast.framework.SessionProvider&#10;import com.google.android.gms.cast.CastMediaControlIntent&#10;&#10;class CastOptionsProvider : OptionsProvider {&#10;    override fun getCastOptions(context: Context): CastOptions {&#10;        return CastOptions.Builder()&#10;            .setReceiverApplicationId(CastMediaControlIntent.DEFAULT_MEDIA_RECEIVER_APPLICATION_ID)&#10;            .build()&#10;    }&#10;&#10;    override fun getAdditionalSessionProviders(context: Context): List&lt;SessionProvider&gt;? {&#10;        return null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.norwedish.twitchchatapp&#13;&#10;&#13;&#10;/**&#13;&#10; * Provides CastOptions used by the Cast SDK integration.&#13;&#10; */&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import com.google.android.gms.cast.framework.CastOptions&#13;&#10;import com.google.android.gms.cast.framework.OptionsProvider&#13;&#10;import com.google.android.gms.cast.framework.SessionProvider&#13;&#10;import com.google.android.gms.cast.CastMediaControlIntent&#13;&#10;&#13;&#10;class CastOptionsProvider : OptionsProvider {&#13;&#10;    override fun getCastOptions(context: Context): CastOptions {&#13;&#10;        return CastOptions.Builder()&#13;&#10;            .setReceiverApplicationId(CastMediaControlIntent.DEFAULT_MEDIA_RECEIVER_APPLICATION_ID)&#13;&#10;            .build()&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun getAdditionalSessionProviders(context: Context): List&lt;SessionProvider&gt;? {&#13;&#10;        return null&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/CastSessionCallbacks.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/CastSessionCallbacks.kt" />
              <option name="originalContent" value="package com.norwedish.twitchchatapp&#10;&#10;import android.util.Log&#10;&#10;/**&#10; * Lightweight helper to notify CastManager when a session starts/ends.&#10; * The MainActivity SessionManagerListener calls these when Cast lifecycle events occur.&#10; */&#10;object CastSessionCallbacks {&#10;    private const val TAG = &quot;CastSessionCallbacks&quot;&#10;&#10;    fun onSessionStarted() {&#10;        Log.i(TAG, &quot;onSessionStarted called - Attempting to load any pending URL&quot;)&#10;        // Attempt to load pending url via CastManager&#10;        CastManager.tryLoadPendingIfAny()&#10;    }&#10;&#10;    fun onSessionEnded() {&#10;        Log.i(TAG, &quot;onSessionEnded called&quot;)&#10;        // Clear the session reference&#10;        CastManager.setCurrentSession(null)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.norwedish.twitchchatapp&#10;&#10;/**&#10; * Callback helpers invoked when Cast sessions start and end; provides hooks to other app components.&#10; */&#10;&#10;import android.util.Log&#10;&#10;/**&#10; * Lightweight helper to notify CastManager when a session starts/ends.&#10; * The MainActivity SessionManagerListener calls these when Cast lifecycle events occur.&#10; */&#10;object CastSessionCallbacks {&#10;    private const val TAG = &quot;CastSessionCallbacks&quot;&#10;&#10;    fun onSessionStarted() {&#10;        Log.i(TAG, &quot;onSessionStarted called - Attempting to load any pending URL&quot;)&#10;        // Attempt to load pending url via CastManager&#10;        CastManager.tryLoadPendingIfAny()&#10;    }&#10;&#10;    fun onSessionEnded() {&#10;        Log.i(TAG, &quot;onSessionEnded called&quot;)&#10;        // Clear the session reference&#10;        CastManager.setCurrentSession(null)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/ChatMessageParser.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/ChatMessageParser.kt" />
              <option name="originalContent" value="package com.norwedish.twitchchatapp&#10;&#10;object ChatMessageParser {&#10;    // Expose a pure function that parses raw IRC chat lines into ChatMessage objects.&#10;    // This is pure Kotlin and has no Android dependencies so it can be unit tested on the JVM.&#10;    fun parse(rawMessage: String): ChatMessage? {&#10;        // Accept prefixes both with and without the '!user@host' part (e.g. ':nick!user@host' and ':tmi.twitch.tv')&#10;        val pattern = Regex(&quot;^(?:@([^ ]+) )?(?::([^! ]+)(?:![^ ]+)? )?([^ ]+)(?: (?!:)([^ ]+))?(?: :(.+))?$&quot;)&#10;        val match = pattern.find(rawMessage)&#10;&#10;        if (match != null) {&#10;            val command = match.groupValues[3]&#10;            if (command != &quot;PRIVMSG&quot; &amp;&amp; command != &quot;USERNOTICE&quot;) {&#10;                return null&#10;            }&#10;&#10;            val tagsPart = match.groupValues[1]&#10;            val loginName = match.groupValues[2]&#10;            val userMessage = match.groupValues[5]&#10;&#10;            var color: String? = null&#10;            var displayName: String? = null&#10;            var twitchEmotes: List&lt;TwitchEmoteInfo&gt; = emptyList()&#10;            var badges: List&lt;String&gt; = emptyList()&#10;            var messageType = MessageType.STANDARD&#10;            var tags: Map&lt;String, String&gt; = emptyMap()&#10;            var finalMessage = &quot;&quot;&#10;&#10;            if (tagsPart.isNotEmpty()) {&#10;                tags = tagsPart.split(';').associate {&#10;                    val parts = it.split('=', limit = 2)&#10;                    if (parts.size == 2) parts[0] to unescapeTagValue(parts[1]) else parts[0] to &quot;&quot;&#10;                }&#10;                color = tags[&quot;color&quot;]&#10;                displayName = tags[&quot;display-name&quot;]&#10;&#10;                val badgesTag = tags[&quot;badges&quot;] ?: &quot;&quot;&#10;                if (badgesTag.isNotBlank()) {&#10;                    badges = badgesTag.split(&quot;,&quot;).map { it.split(&quot;/&quot;).first() }&#10;                }&#10;&#10;                val emoteTag = tags[&quot;emotes&quot;] ?: &quot;&quot;&#10;                if (emoteTag.isNotEmpty()) {&#10;                    // Note: Emote indices are based on the user's raw trailing message&#10;                    twitchEmotes = EmoteParser.parse(emoteTag).map { TwitchEmoteInfo(it.id, it.startIndex, it.endIndex) }&#10;                }&#10;&#10;                if (command == &quot;USERNOTICE&quot;) {&#10;                    val msgId = tags[&quot;msg-id&quot;]&#10;&#10;                    // Poll-related notices are handled elsewhere in the service pipeline; ignore here&#10;                    if (msgId?.startsWith(&quot;channel.poll.&quot;) == true) {&#10;                        return null&#10;                    }&#10;&#10;                    messageType = when (msgId) {&#10;                        &quot;sub&quot;, &quot;resub&quot;, &quot;subgift&quot;, &quot;anonsubgift&quot;, &quot;submysterygift&quot;, &quot;anonsubmysterygift&quot;, &quot;primepaidupgrade&quot;, &quot;giftpaidupgrade&quot; -&gt; MessageType.SUBSCRIPTION&#10;                        &quot;raid&quot; -&gt; MessageType.RAID&#10;                        &quot;announcement&quot; -&gt; MessageType.ANNOUNCEMENT&#10;                        else -&gt; messageType&#10;                    }&#10;&#10;                    // For USERNOTICE, prefer the system message text (this contains the human-readable sub/raid text).&#10;                    // Some USERNOTICE variants include the user's own message in the trailing portion; append it when present.&#10;                    finalMessage = tags[&quot;system-msg&quot;] ?: &quot;&quot;&#10;                    if (userMessage.isNotEmpty()) {&#10;                        finalMessage += &quot;\n$userMessage&quot;&#10;                    }&#10;                } else { // PRIVMSG&#10;                    finalMessage = userMessage&#10;                    val isReply = tags.containsKey(&quot;reply-parent-msg-id&quot;)&#10;                    if (isReply) {&#10;                        val replyTo = tags[&quot;reply-parent-user-login&quot;]&#10;                        if (replyTo != null &amp;&amp; finalMessage.startsWith(&quot;@$replyTo&quot;, ignoreCase = true)) {&#10;                            val endOfMention = finalMessage.indexOf(' ')&#10;                            if (endOfMention != -1) {&#10;                                finalMessage = finalMessage.substring(endOfMention + 1)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Now we must map emote indices (which are relative to the original userMessage) to indices in finalMessage.&#10;            // There are a few cases:&#10;            //  - For PRIVMSG where we trimmed an @mention prefix, finalMessage will be a suffix of userMessage. We should subtract the prefix length.&#10;            //  - For USERNOTICE where finalMessage = system-msg + &quot;\n&quot; + userMessage, userMessage appears inside finalMessage at some index; we should add that index to each emote index.&#10;            //  - Other cases: fallback to attempting to find a best-effort mapping.&#10;&#10;            val parsedTwitchEmotes = mutableListOf&lt;ParsedEmote&gt;()&#10;            if (twitchEmotes.isNotEmpty()) {&#10;                for (t in twitchEmotes) {&#10;                    val startInFinal = when {&#10;                        // If finalMessage contains the original userMessage, shift by its index in finalMessage&#10;                        finalMessage.contains(userMessage) &amp;&amp; userMessage.isNotEmpty() -&gt; finalMessage.indexOf(userMessage) + t.startIndex&#10;                        // If userMessage contains finalMessage (we trimmed prefix), then subtract the trimmed prefix length&#10;                        userMessage.contains(finalMessage) &amp;&amp; finalMessage.isNotEmpty() -&gt; t.startIndex - userMessage.indexOf(finalMessage)&#10;                        // Otherwise try to map by locating the emote text itself in finalMessage&#10;                        else -&gt; {&#10;                            // Try to get the emote code from userMessage and search for it in finalMessage&#10;                            val safeStart = t.startIndex.coerceAtLeast(0).coerceAtMost(userMessage.length - 1)&#10;                            val safeEnd = t.endIndex.coerceAtLeast(0).coerceAtMost(userMessage.length - 1)&#10;                            val code = try {&#10;                                userMessage.substring(safeStart, safeEnd + 1)&#10;                            } catch (_: Exception) {&#10;                                null&#10;                            }&#10;                            if (code != null &amp;&amp; code.isNotEmpty()) {&#10;                                finalMessage.indexOf(code).takeIf { it &gt;= 0 } ?: t.startIndex&#10;                            } else {&#10;                                t.startIndex&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    val endInFinal = startInFinal + (t.endIndex - t.startIndex)&#10;&#10;                    // Extract code safely from finalMessage if indices valid, else fallback to code from userMessage&#10;                    val code = if (startInFinal &gt;= 0 &amp;&amp; endInFinal &lt; finalMessage.length &amp;&amp; finalMessage.isNotEmpty()) {&#10;                        finalMessage.substring(startInFinal, endInFinal + 1)&#10;                    } else {&#10;                        // try to get from original userMessage&#10;                        try {&#10;                            userMessage.substring(t.startIndex, t.endIndex + 1)&#10;                        } catch (_: Exception) {&#10;                            &quot;&quot;&#10;                        }&#10;                    }&#10;&#10;                    if (code.isNotEmpty()) {&#10;                        parsedTwitchEmotes.add(&#10;                            ParsedEmote(&#10;                                emote = Emote(&#10;                                    id = t.id,&#10;                                    code = code,&#10;                                    url = &quot;https://static-cdn.jtvnw.net/emoticons/v2/${t.id}/default/dark/1.0&quot;,&#10;                                    provider = EmoteProvider.TWITCH&#10;                                ),&#10;                                startIndex = startInFinal,&#10;                                endIndex = endInFinal&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Parse third-party emotes from the finalMessage (what will be displayed) so positions match&#10;            val thirdPartyEmotes = EmoteManager.parseThirdPartyEmotes(finalMessage)&#10;&#10;            val allEmotes = (parsedTwitchEmotes + thirdPartyEmotes).sortedBy { it.startIndex }&#10;&#10;            var finalColor = color&#10;            if (finalColor.isNullOrEmpty()) {&#10;                finalColor = &quot;#8A2BE2&quot; // Default color&#10;            } else if (finalColor.equals(&quot;#000000&quot;, ignoreCase = true)) {&#10;                finalColor = &quot;#FFFFFF&quot; // Change black to white for readability&#10;            }&#10;&#10;            // For USERNOTICE (system messages like subs/raids), prefer tag-derived author info (tags may contain login/display-name).&#10;            // The prefix-derived loginName for USERNOTICE can be &quot;tmi.twitch.tv&quot;, which is not a real user.&#10;            // Use a list of possible tag keys returned in various USERNOTICE variants (gifts, recipients, anon gifter, etc.)&#10;            val (authorLoginForMsg, author) = if (command == &quot;USERNOTICE&quot;) {&#10;                val loginCandidates = listOf(&#10;                    &quot;login&quot;,&#10;                    &quot;msg-param-sender-login&quot;,&#10;                    &quot;msg-param-gifter-login&quot;,&#10;                    &quot;msg-param-recipient-login&quot;,&#10;                    &quot;msg-param-recipient-user-login&quot;,&#10;                    &quot;msg-param-user-login&quot;&#10;                )&#10;                val displayNameCandidates = listOf(&#10;                    &quot;display-name&quot;,&#10;                    &quot;msg-param-sender-display-name&quot;,&#10;                    &quot;msg-param-gifter-display-name&quot;,&#10;                    &quot;msg-param-recipient-display-name&quot;,&#10;                    &quot;msg-param-recipient-user-name&quot;&#10;                )&#10;&#10;                val foundLogin = loginCandidates.asSequence().mapNotNull { tags[it]?.takeIf { it.isNotEmpty() } }.firstOrNull()&#10;                var foundName = displayNameCandidates.asSequence().mapNotNull { tags[it]?.takeIf { it.isNotEmpty() } }.firstOrNull() ?: foundLogin&#10;&#10;                // If still null for subscription-type notices, try recipient tags (common for gifted subs)&#10;                if (messageType == MessageType.SUBSCRIPTION &amp;&amp; foundName.isNullOrEmpty()) {&#10;                    val recipientCandidates = listOf(&#10;                        &quot;msg-param-recipient-display-name&quot;,&#10;                        &quot;msg-param-recipient-user-name&quot;,&#10;                        &quot;msg-param-recipient-login&quot;,&#10;                        &quot;msg-param-recipient-user-login&quot;&#10;                    )&#10;                    foundName = recipientCandidates.asSequence().mapNotNull { tags[it]?.takeIf { it.isNotEmpty() } }.firstOrNull() ?: foundName&#10;&#10;                    if (foundName.isNullOrEmpty()) {&#10;                        val sys = tags[&quot;system-msg&quot;] ?: &quot;&quot;&#10;                        val plain = sys.replace(Regex(&quot;&lt;[^&gt;]*&gt;&quot;), &quot;&quot;).replace(&quot;&amp;amp;&quot;, &quot;&amp;&quot;).replace(&quot;&amp;lt;&quot;, &quot;&lt;&quot;).replace(&quot;&amp;gt;&quot;, &quot;&gt;&quot;).trim()&#10;                        foundName = Regex(&quot;^([\\w\\u00C0-\\u017F'\\-]+)&quot;).find(plain)?.groupValues?.get(1)&#10;                    }&#10;                }&#10;&#10;                Pair(foundLogin, foundName)&#10;            } else {&#10;                Pair(loginName.takeIf { it.isNotEmpty() }, displayName?.takeIf { it.isNotEmpty() } ?: loginName.takeIf { it.isNotEmpty() })&#10;            }&#10;&#10;            return ChatMessage(&#10;                author = author,&#10;                authorLogin = authorLoginForMsg,&#10;                message = finalMessage,&#10;                authorColor = finalColor,&#10;                emotes = allEmotes,&#10;                badges = badges,&#10;                type = messageType,&#10;                tags = tags,&#10;                replyParentMsgId = tags[&quot;reply-parent-msg-id&quot;],&#10;                replyParentUserLogin = tags[&quot;reply-parent-user-login&quot;],&#10;                replyParentMsgBody = tags[&quot;reply-parent-msg-body&quot;]&#10;            )&#10;        }&#10;        return null&#10;    }&#10;&#10;    private fun unescapeTagValue(value: String?): String {&#10;        if (value == null) return &quot;&quot;&#10;        return value.replace(&quot;\\s&quot;, &quot; &quot;)&#10;            .replace(&quot;\\:&quot;, &quot;;&quot;)&#10;            .replace(&quot;\\r&quot;, &quot;\r&quot;)&#10;            .replace(&quot;\\n&quot;, &quot;\n&quot;)&#10;            .replace(&quot;\\\\&quot;, &quot;\\&quot;)&#10;    }&#10;&#10;    // Debug helper: returns information about regex matching/group extraction for troubleshooting.&#10;    fun debugParseInfo(rawMessage: String): String {&#10;        val pattern = Regex(&quot;^(?:@([^ ]+) )?(?::([^! ]+)(?:![^ ]+)? )?([^ ]+)(?: (?!:)([^ ]+))?(?: :(.+))?$&quot;)&#10;        val match = pattern.find(rawMessage)&#10;        if (match == null) {&#10;            return &quot;NO_MATCH: raw=\n${rawMessage.replace(&quot;\n&quot;, &quot;\\n&quot;)}&quot;&#10;        }&#10;        val groups = (1..match.groupValues.size - 1).joinToString(separator = &quot; | &quot;) { idx -&gt;&#10;            &quot;g$idx='${match.groupValues[idx]}'&quot;&#10;        }&#10;        return &quot;MATCH: command=${match.groupValues[3]} | groups: $groups&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.norwedish.twitchchatapp&#13;&#10;&#13;&#10;/**&#13;&#10; * Centralized parser for raw IRC messages from Twitch chat. Produces ChatMessage objects consumed by UI.&#13;&#10; */&#13;&#10;&#13;&#10;object ChatMessageParser {&#13;&#10;    // Expose a pure function that parses raw IRC chat lines into ChatMessage objects.&#13;&#10;    // This is pure Kotlin and has no Android dependencies so it can be unit tested on the JVM.&#13;&#10;    fun parse(rawMessage: String): ChatMessage? {&#13;&#10;        // Accept prefixes both with and without the '!user@host' part (e.g. ':nick!user@host' and ':tmi.twitch.tv')&#13;&#10;        val pattern = Regex(&quot;^(?:@([^ ]+) )?(?::([^! ]+)(?:![^ ]+)? )?([^ ]+)(?: (?!:)([^ ]+))?(?: :(.+))?$&quot;)&#13;&#10;        val match = pattern.find(rawMessage)&#13;&#10;&#13;&#10;        if (match != null) {&#13;&#10;            val command = match.groupValues[3]&#13;&#10;            if (command != &quot;PRIVMSG&quot; &amp;&amp; command != &quot;USERNOTICE&quot;) {&#13;&#10;                return null&#13;&#10;            }&#13;&#10;&#13;&#10;            val tagsPart = match.groupValues[1]&#13;&#10;            val loginName = match.groupValues[2]&#13;&#10;            val userMessage = match.groupValues[5]&#13;&#10;&#13;&#10;            var color: String? = null&#13;&#10;            var displayName: String? = null&#13;&#10;            var twitchEmotes: List&lt;TwitchEmoteInfo&gt; = emptyList()&#13;&#10;            var badges: List&lt;String&gt; = emptyList()&#13;&#10;            var messageType = MessageType.STANDARD&#13;&#10;            var tags: Map&lt;String, String&gt; = emptyMap()&#13;&#10;            var finalMessage = &quot;&quot;&#13;&#10;&#13;&#10;            if (tagsPart.isNotEmpty()) {&#13;&#10;                tags = tagsPart.split(';').associate {&#13;&#10;                    val parts = it.split('=', limit = 2)&#13;&#10;                    if (parts.size == 2) parts[0] to unescapeTagValue(parts[1]) else parts[0] to &quot;&quot;&#13;&#10;                }&#13;&#10;                color = tags[&quot;color&quot;]&#13;&#10;                displayName = tags[&quot;display-name&quot;]&#13;&#10;&#13;&#10;                val badgesTag = tags[&quot;badges&quot;] ?: &quot;&quot;&#13;&#10;                if (badgesTag.isNotBlank()) {&#13;&#10;                    badges = badgesTag.split(&quot;,&quot;).map { it.split(&quot;/&quot;).first() }&#13;&#10;                }&#13;&#10;&#13;&#10;                val emoteTag = tags[&quot;emotes&quot;] ?: &quot;&quot;&#13;&#10;                if (emoteTag.isNotEmpty()) {&#13;&#10;                    // Note: Emote indices are based on the user's raw trailing message&#13;&#10;                    twitchEmotes = EmoteParser.parse(emoteTag).map { TwitchEmoteInfo(it.id, it.startIndex, it.endIndex) }&#13;&#10;                }&#13;&#10;&#13;&#10;                if (command == &quot;USERNOTICE&quot;) {&#13;&#10;                    val msgId = tags[&quot;msg-id&quot;]&#13;&#10;&#13;&#10;                    // Poll-related notices are handled elsewhere in the service pipeline; ignore here&#13;&#10;                    if (msgId?.startsWith(&quot;channel.poll.&quot;) == true) {&#13;&#10;                        return null&#13;&#10;                    }&#13;&#10;&#13;&#10;                    messageType = when (msgId) {&#13;&#10;                        &quot;sub&quot;, &quot;resub&quot;, &quot;subgift&quot;, &quot;anonsubgift&quot;, &quot;submysterygift&quot;, &quot;anonsubmysterygift&quot;, &quot;primepaidupgrade&quot;, &quot;giftpaidupgrade&quot; -&gt; MessageType.SUBSCRIPTION&#13;&#10;                        &quot;raid&quot; -&gt; MessageType.RAID&#13;&#10;                        &quot;announcement&quot; -&gt; MessageType.ANNOUNCEMENT&#13;&#10;                        else -&gt; messageType&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // For USERNOTICE, prefer the system message text (this contains the human-readable sub/raid text).&#13;&#10;                    // Some USERNOTICE variants include the user's own message in the trailing portion; append it when present.&#13;&#10;                    finalMessage = tags[&quot;system-msg&quot;] ?: &quot;&quot;&#13;&#10;                    if (userMessage.isNotEmpty()) {&#13;&#10;                        finalMessage += &quot;\n$userMessage&quot;&#13;&#10;                    }&#13;&#10;                } else { // PRIVMSG&#13;&#10;                    finalMessage = userMessage&#13;&#10;                    val isReply = tags.containsKey(&quot;reply-parent-msg-id&quot;)&#13;&#10;                    if (isReply) {&#13;&#10;                        val replyTo = tags[&quot;reply-parent-user-login&quot;]&#13;&#10;                        if (replyTo != null &amp;&amp; finalMessage.startsWith(&quot;@$replyTo&quot;, ignoreCase = true)) {&#13;&#10;                            val endOfMention = finalMessage.indexOf(' ')&#13;&#10;                            if (endOfMention != -1) {&#13;&#10;                                finalMessage = finalMessage.substring(endOfMention + 1)&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            // Now we must map emote indices (which are relative to the original userMessage) to indices in finalMessage.&#13;&#10;            // There are a few cases:&#13;&#10;            //  - For PRIVMSG where we trimmed an @mention prefix, finalMessage will be a suffix of userMessage. We should subtract the prefix length.&#13;&#10;            //  - For USERNOTICE where finalMessage = system-msg + &quot;\n&quot; + userMessage, userMessage appears inside finalMessage at some index; we should add that index to each emote index.&#13;&#10;            //  - Other cases: fallback to attempting to find a best-effort mapping.&#13;&#10;&#13;&#10;            val parsedTwitchEmotes = mutableListOf&lt;ParsedEmote&gt;()&#13;&#10;            if (twitchEmotes.isNotEmpty()) {&#13;&#10;                for (t in twitchEmotes) {&#13;&#10;                    val startInFinal = when {&#13;&#10;                        // If finalMessage contains the original userMessage, shift by its index in finalMessage&#13;&#10;                        finalMessage.contains(userMessage) &amp;&amp; userMessage.isNotEmpty() -&gt; finalMessage.indexOf(userMessage) + t.startIndex&#13;&#10;                        // If userMessage contains finalMessage (we trimmed prefix), then subtract the trimmed prefix length&#13;&#10;                        userMessage.contains(finalMessage) &amp;&amp; finalMessage.isNotEmpty() -&gt; t.startIndex - userMessage.indexOf(finalMessage)&#13;&#10;                        // Otherwise try to map by locating the emote text itself in finalMessage&#13;&#10;                        else -&gt; {&#13;&#10;                            // Try to get the emote code from userMessage and search for it in finalMessage&#13;&#10;                            val safeStart = t.startIndex.coerceAtLeast(0).coerceAtMost(userMessage.length - 1)&#13;&#10;                            val safeEnd = t.endIndex.coerceAtLeast(0).coerceAtMost(userMessage.length - 1)&#13;&#10;                            val code = try {&#13;&#10;                                userMessage.substring(safeStart, safeEnd + 1)&#13;&#10;                            } catch (_: Exception) {&#13;&#10;                                null&#13;&#10;                            }&#13;&#10;                            if (code != null &amp;&amp; code.isNotEmpty()) {&#13;&#10;                                finalMessage.indexOf(code).takeIf { it &gt;= 0 } ?: t.startIndex&#13;&#10;                            } else {&#13;&#10;                                t.startIndex&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    val endInFinal = startInFinal + (t.endIndex - t.startIndex)&#13;&#10;&#13;&#10;                    // Extract code safely from finalMessage if indices valid, else fallback to code from userMessage&#13;&#10;                    val code = if (startInFinal &gt;= 0 &amp;&amp; endInFinal &lt; finalMessage.length &amp;&amp; finalMessage.isNotEmpty()) {&#13;&#10;                        finalMessage.substring(startInFinal, endInFinal + 1)&#13;&#10;                    } else {&#13;&#10;                        // try to get from original userMessage&#13;&#10;                        try {&#13;&#10;                            userMessage.substring(t.startIndex, t.endIndex + 1)&#13;&#10;                        } catch (_: Exception) {&#13;&#10;                            &quot;&quot;&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    if (code.isNotEmpty()) {&#13;&#10;                        parsedTwitchEmotes.add(&#13;&#10;                            ParsedEmote(&#13;&#10;                                emote = Emote(&#13;&#10;                                    id = t.id,&#13;&#10;                                    code = code,&#13;&#10;                                    url = &quot;https://static-cdn.jtvnw.net/emoticons/v2/${t.id}/default/dark/1.0&quot;,&#13;&#10;                                    provider = EmoteProvider.TWITCH&#13;&#10;                                ),&#13;&#10;                                startIndex = startInFinal,&#13;&#10;                                endIndex = endInFinal&#13;&#10;                            )&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            // Parse third-party emotes from the finalMessage (what will be displayed) so positions match&#13;&#10;            val thirdPartyEmotes = EmoteManager.parseThirdPartyEmotes(finalMessage)&#13;&#10;&#13;&#10;            val allEmotes = (parsedTwitchEmotes + thirdPartyEmotes).sortedBy { it.startIndex }&#13;&#10;&#13;&#10;            var finalColor = color&#13;&#10;            if (finalColor.isNullOrEmpty()) {&#13;&#10;                finalColor = &quot;#8A2BE2&quot; // Default color&#13;&#10;            } else if (finalColor.equals(&quot;#000000&quot;, ignoreCase = true)) {&#13;&#10;                finalColor = &quot;#FFFFFF&quot; // Change black to white for readability&#13;&#10;            }&#13;&#10;&#13;&#10;            // For USERNOTICE (system messages like subs/raids), prefer tag-derived author info (tags may contain login/display-name).&#13;&#10;            // The prefix-derived loginName for USERNOTICE can be &quot;tmi.twitch.tv&quot;, which is not a real user.&#13;&#10;            // Use a list of possible tag keys returned in various USERNOTICE variants (gifts, recipients, anon gifter, etc.)&#13;&#10;            val (authorLoginForMsg, author) = if (command == &quot;USERNOTICE&quot;) {&#13;&#10;                val loginCandidates = listOf(&#13;&#10;                    &quot;login&quot;,&#13;&#10;                    &quot;msg-param-sender-login&quot;,&#13;&#10;                    &quot;msg-param-gifter-login&quot;,&#13;&#10;                    &quot;msg-param-recipient-login&quot;,&#13;&#10;                    &quot;msg-param-recipient-user-login&quot;,&#13;&#10;                    &quot;msg-param-user-login&quot;&#13;&#10;                )&#13;&#10;                val displayNameCandidates = listOf(&#13;&#10;                    &quot;display-name&quot;,&#13;&#10;                    &quot;msg-param-sender-display-name&quot;,&#13;&#10;                    &quot;msg-param-gifter-display-name&quot;,&#13;&#10;                    &quot;msg-param-recipient-display-name&quot;,&#13;&#10;                    &quot;msg-param-recipient-user-name&quot;&#13;&#10;                )&#13;&#10;&#13;&#10;                val foundLogin = loginCandidates.asSequence().mapNotNull { tags[it]?.takeIf { it.isNotEmpty() } }.firstOrNull()&#13;&#10;                var foundName = displayNameCandidates.asSequence().mapNotNull { tags[it]?.takeIf { it.isNotEmpty() } }.firstOrNull() ?: foundLogin&#13;&#10;&#13;&#10;                // If still null for subscription-type notices, try recipient tags (common for gifted subs)&#13;&#10;                if (messageType == MessageType.SUBSCRIPTION &amp;&amp; foundName.isNullOrEmpty()) {&#13;&#10;                    val recipientCandidates = listOf(&#13;&#10;                        &quot;msg-param-recipient-display-name&quot;,&#13;&#10;                        &quot;msg-param-recipient-user-name&quot;,&#13;&#10;                        &quot;msg-param-recipient-login&quot;,&#13;&#10;                        &quot;msg-param-recipient-user-login&quot;&#13;&#10;                    )&#13;&#10;                    foundName = recipientCandidates.asSequence().mapNotNull { tags[it]?.takeIf { it.isNotEmpty() } }.firstOrNull() ?: foundName&#13;&#10;&#13;&#10;                    if (foundName.isNullOrEmpty()) {&#13;&#10;                        val sys = tags[&quot;system-msg&quot;] ?: &quot;&quot;&#13;&#10;                        val plain = sys.replace(Regex(&quot;&lt;[^&gt;]*&gt;&quot;), &quot;&quot;).replace(&quot;&amp;amp;&quot;, &quot;&amp;&quot;).replace(&quot;&amp;lt;&quot;, &quot;&lt;&quot;).replace(&quot;&amp;gt;&quot;, &quot;&gt;&quot;).trim()&#13;&#10;                        foundName = Regex(&quot;^([\\w\\u00C0-\\u017F'\\-]+)&quot;).find(plain)?.groupValues?.get(1)&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                Pair(foundLogin, foundName)&#13;&#10;            } else {&#13;&#10;                Pair(loginName.takeIf { it.isNotEmpty() }, displayName?.takeIf { it.isNotEmpty() } ?: loginName.takeIf { it.isNotEmpty() })&#13;&#10;            }&#13;&#10;&#13;&#10;            return ChatMessage(&#13;&#10;                author = author,&#13;&#10;                authorLogin = authorLoginForMsg,&#13;&#10;                message = finalMessage,&#13;&#10;                authorColor = finalColor,&#13;&#10;                emotes = allEmotes,&#13;&#10;                badges = badges,&#13;&#10;                type = messageType,&#13;&#10;                tags = tags,&#13;&#10;                replyParentMsgId = tags[&quot;reply-parent-msg-id&quot;],&#13;&#10;                replyParentUserLogin = tags[&quot;reply-parent-user-login&quot;],&#13;&#10;                replyParentMsgBody = tags[&quot;reply-parent-msg-body&quot;]&#13;&#10;            )&#13;&#10;        }&#13;&#10;        return null&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun unescapeTagValue(value: String?): String {&#13;&#10;        if (value == null) return &quot;&quot;&#13;&#10;        return value.replace(&quot;\\s&quot;, &quot; &quot;)&#13;&#10;            .replace(&quot;\\:&quot;, &quot;;&quot;)&#13;&#10;            .replace(&quot;\\r&quot;, &quot;\r&quot;)&#13;&#10;            .replace(&quot;\\n&quot;, &quot;\n&quot;)&#13;&#10;            .replace(&quot;\\\\&quot;, &quot;\\&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    // Debug helper: returns information about regex matching/group extraction for troubleshooting.&#13;&#10;    fun debugParseInfo(rawMessage: String): String {&#13;&#10;        val pattern = Regex(&quot;^(?:@([^ ]+) )?(?::([^! ]+)(?:![^ ]+)? )?([^ ]+)(?: (?!:)([^ ]+))?(?: :(.+))?$&quot;)&#13;&#10;        val match = pattern.find(rawMessage)&#13;&#10;        if (match == null) {&#13;&#10;            return &quot;NO_MATCH: raw=\n${rawMessage.replace(&quot;\n&quot;, &quot;\\n&quot;)}&quot;&#13;&#10;        }&#13;&#10;        val groups = (1..match.groupValues.size - 1).joinToString(separator = &quot; | &quot;) { idx -&gt;&#13;&#10;            &quot;g$idx='${match.groupValues[idx]}'&quot;&#13;&#10;        }&#13;&#10;        return &quot;MATCH: command=${match.groupValues[3]} | groups: $groups&quot;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/LocalProxyServer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/LocalProxyServer.kt" />
              <option name="originalContent" value="package com.norwedish.twitchchatapp&#10;&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import fi.iki.elonen.NanoHTTPD&#10;import java.io.InputStream&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;import java.net.URLEncoder&#10;import java.net.InetAddress&#10;import java.net.NetworkInterface&#10;&#10;object LocalProxyServer {&#10;    private const val TAG = &quot;LocalProxyServer&quot;&#10;    private var server: NanoProxy? = null&#10;    private var port: Int = 0&#10;    private var baseUrlCache: String? = null&#10;    // Diagnostics&#10;    @Volatile&#10;    var lastPlaylistRequested: String? = null&#10;        private set&#10;    @Volatile&#10;    var segmentRequestCount: Int = 0&#10;        private set&#10;    @Volatile&#10;    var lastSegmentStatus: Int? = null&#10;        private set&#10;&#10;    // Start the local proxy on an automatically chosen free port.&#10;    // onStarted(baseUrl) will be invoked on the main thread with a reachable base URL (http://&lt;device-ip&gt;:port)&#10;    fun start(onStarted: ((baseUrl: String) -&gt; Unit)? = null) {&#10;        if (server != null) {&#10;            onStarted?.invoke(getBaseUrl())&#10;            return&#10;        }&#10;&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                val s = NanoProxy(0)&#10;                s.start(NanoHTTPD.SOCKET_READ_TIMEOUT, false)&#10;                server = s&#10;                port = s.listeningPort&#10;&#10;                // Determine a LAN-reachable IP address to present to Chromecast&#10;                val ip = findLocalIpAddress() ?: &quot;127.0.0.1&quot;&#10;                baseUrlCache = &quot;http://$ip:$port&quot;&#10;&#10;                val base = baseUrlCache ?: &quot;&quot;&#10;                Log.i(TAG, &quot;Local proxy started at $base&quot;)&#10;                withContext(Dispatchers.Main) {&#10;                    onStarted?.invoke(base)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Failed to start local proxy: ${e.message}&quot;, e)&#10;                withContext(Dispatchers.Main) {&#10;                    onStarted?.invoke(&quot;&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun stop() {&#10;        try {&#10;            server?.stop()&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Error stopping local proxy: ${e.message}&quot;)&#10;        }&#10;        server = null&#10;        port = 0&#10;        baseUrlCache = null&#10;    }&#10;&#10;    fun isRunning(): Boolean = server != null&#10;&#10;    fun getBaseUrl(): String = baseUrlCache ?: &quot;http://127.0.0.1:${port}&quot;&#10;&#10;    fun localPlaylistUrlFor(remoteM3u8: String): String {&#10;        // Ensure server is started asynchronously if not running&#10;        if (!isRunning()) start()&#10;        val encoded = URLEncoder.encode(remoteM3u8, &quot;UTF-8&quot;)&#10;        return &quot;${getBaseUrl()}/stream?source=$encoded&quot;&#10;    }&#10;&#10;    private fun findLocalIpAddress(): String? {&#10;        try {&#10;            val interfaces = NetworkInterface.getNetworkInterfaces()&#10;            for (intf in interfaces) {&#10;                val addrs = intf.inetAddresses&#10;                for (addr in addrs) {&#10;                    if (!addr.isLoopbackAddress &amp;&amp; addr is InetAddress) {&#10;                        val host = addr.hostAddress&#10;                        // prefer IPv4&#10;                        if (host.indexOf(':') &lt; 0) {&#10;                            return host&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Failed to enumerate network interfaces: ${e.message}&quot;)&#10;        }&#10;        return null&#10;    }&#10;&#10;    private class NanoProxy(port: Int) : NanoHTTPD(port) {&#10;        override fun serve(session: IHTTPSession): Response {&#10;            val uri = session.uri&#10;            return try {&#10;                if (uri == &quot;/status&quot;) {&#10;                    val body = &quot;lastPlaylist=${lastPlaylistRequested ?: &quot;&lt;none&gt;&quot;}\nsegmentRequests=$segmentRequestCount\nlastSegmentStatus=${lastSegmentStatus ?: &quot;&lt;none&gt;&quot;}\n&quot;&#10;                    return newFixedLengthResponse(Response.Status.OK, &quot;text/plain&quot;, body)&#10;                }&#10;                when (uri) {&#10;                    &quot;/stream&quot; -&gt; handleStream(session)&#10;                    &quot;/segment&quot; -&gt; handleSegment(session)&#10;                    else -&gt; newFixedLengthResponse(Response.Status.OK, &quot;text/plain&quot;, &quot;LocalProxy running&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;NanoProxy serve error: ${e.message}&quot;, e)&#10;                newFixedLengthResponse(Response.Status.INTERNAL_ERROR, &quot;text/plain&quot;, &quot;proxy error: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        private fun handleStream(session: IHTTPSession): Response {&#10;            val params = session.parameters&#10;            val src = params[&quot;source&quot;]?.firstOrNull() ?: return newFixedLengthResponse(Response.Status.BAD_REQUEST, &quot;text/plain&quot;, &quot;missing source&quot;)&#10;            val remote = java.net.URL(java.net.URLDecoder.decode(src, &quot;UTF-8&quot;))&#10;&#10;            try {&#10;                Log.d(TAG, &quot;handleStream request for remote playlist: ${remote}&quot;)&#10;                lastPlaylistRequested = remote.toString()&#10;                val conn = remote.openConnection() as HttpURLConnection&#10;                conn.instanceFollowRedirects = true&#10;                // Use a browser-like User-Agent to increase acceptance by remote servers (Twitch sometimes blocks non-browser UAs)&#10;                conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Android 10; Mobile; rv:115.0) Gecko/115.0 Firefox/115.0&quot;)&#10;                conn.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;)&#10;                conn.setRequestProperty(&quot;Referer&quot;, &quot;https://www.twitch.tv/&quot;)&#10;                conn.connectTimeout = 8000&#10;                conn.readTimeout = 15000&#10;                conn.connect()&#10;                val code = conn.responseCode&#10;                Log.d(TAG, &quot;Fetched remote playlist: ${remote} -&gt; HTTP $code&quot;)&#10;                if (code !in 200..299) {&#10;                    val msg = conn.responseMessage&#10;                    conn.disconnect()&#10;                    return newFixedLengthResponse(Response.Status.lookup(code), &quot;text/plain&quot;, &quot;fetch failed: $code $msg&quot;)&#10;                }&#10;&#10;                val text = conn.inputStream.bufferedReader().use { it.readText() }&#10;                conn.disconnect()&#10;&#10;                // Rewrite URI lines&#10;                val base = remote&#10;                val hostHeader = session.headers[&quot;host&quot;]&#10;                val host = hostHeader ?: &quot;${findLocalIpAddress() ?: &quot;127.0.0.1&quot;}:$listeningPort&quot;&#10;                val prefix = &quot;http://$host&quot;&#10;&#10;                val rewritten = text.lines().joinToString(separator = &quot;\r\n&quot;) { line -&gt;&#10;                    val trim = line.trim()&#10;                    if (trim.isEmpty() || trim.startsWith(&quot;#&quot;)) return@joinToString line&#10;                    try {&#10;                        val resolved = URL(base, trim).toString()&#10;                        val enc = URLEncoder.encode(resolved, &quot;UTF-8&quot;)&#10;                        Log.d(TAG, &quot;Rewriting playlist line. original=$trim resolved=$resolved -&gt; $prefix/segment?u=$enc&quot;)&#10;                        &quot;$prefix/segment?u=$enc&quot;&#10;                    } catch (e: Exception) {&#10;                        line&#10;                    }&#10;                }&#10;&#10;                // Use application/x-mpegURL which is commonly accepted for HLS playlists&#10;                val resp = newFixedLengthResponse(Response.Status.OK, &quot;application/x-mpegURL&quot;, rewritten)&#10;                resp.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#10;                resp.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Range,Content-Type&quot;)&#10;                Log.d(TAG, &quot;Returning rewritten playlist to client: ${session.remoteIpAddress}&quot;)&#10;                return resp&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;handleStream error: ${e.message}&quot;, e)&#10;                return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, &quot;text/plain&quot;, &quot;error: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        private fun handleSegment(session: IHTTPSession): Response {&#10;            val params = session.parameters&#10;            val enc = params[&quot;u&quot;]?.firstOrNull() ?: return newFixedLengthResponse(Response.Status.BAD_REQUEST, &quot;text/plain&quot;, &quot;missing u&quot;)&#10;            val remoteUrl = java.net.URL(java.net.URLDecoder.decode(enc, &quot;UTF-8&quot;))&#10;            try {&#10;                Log.d(TAG, &quot;handleSegment request for: $remoteUrl from ${session.remoteIpAddress}; headers=${session.headers}&quot;)&#10;                val conn = remoteUrl.openConnection() as HttpURLConnection&#10;                conn.instanceFollowRedirects = true&#10;                // Forward Range header if present&#10;                val range = session.headers[&quot;range&quot;]&#10;                if (!range.isNullOrEmpty()) conn.setRequestProperty(&quot;Range&quot;, range)&#10;                if (!range.isNullOrEmpty()) Log.d(TAG, &quot;Forwarding Range header to remote: $range&quot;)&#10;                // Use a browser-like User-Agent for segment requests as well&#10;                conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Android 10; Mobile; rv:115.0) Gecko/115.0 Firefox/115.0&quot;)&#10;                conn.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;)&#10;                conn.setRequestProperty(&quot;Referer&quot;, &quot;https://www.twitch.tv/&quot;)&#10;                conn.connectTimeout = 10000&#10;                conn.readTimeout = 20000&#10;                conn.connect()&#10;&#10;                val code = conn.responseCode&#10;                Log.d(TAG, &quot;Remote segment responded with HTTP $code for $remoteUrl&quot;)&#10;                // diagnostics&#10;                synchronized(this@LocalProxyServer) { segmentRequestCount++ }&#10;                lastSegmentStatus = code&#10;                val contentType = conn.contentType ?: &quot;application/octet-stream&quot;&#10;&#10;                // Read the remote response into memory so we can return a fixed-length response&#10;                val bytes = conn.inputStream.use { it.readBytes() }&#10;                val remoteContentLength = conn.getHeaderFieldInt(&quot;Content-Length&quot;, bytes.size)&#10;                Log.d(TAG, &quot;Remote Content-Length header: $remoteContentLength, buffered ${bytes.size} bytes&quot;)&#10;                val resp = newFixedLengthResponse(Response.Status.lookup(code), contentType, bytes.inputStream(), bytes.size.toLong())&#10;                // forward content-range/length if available&#10;                conn.headerFields[&quot;Content-Range&quot;]?.firstOrNull()?.let { resp.addHeader(&quot;Content-Range&quot;, it) }&#10;                conn.getHeaderField(&quot;Accept-Ranges&quot;)?.let { resp.addHeader(&quot;Accept-Ranges&quot;, it) }&#10;                // Ensure Content-Length is forwarded if available&#10;                try { resp.addHeader(&quot;Content-Length&quot;, bytes.size.toString()) } catch (_: Exception) {}&#10;                // CORS for clients that may enforce it&#10;                try { resp.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) } catch (_: Exception) {}&#10;                try { resp.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Range,Content-Type&quot;) } catch (_: Exception) {}&#10;                Log.d(TAG, &quot;Responding to client ${session.remoteIpAddress} with contentType=$contentType, code=$code&quot;)&#10;                return resp&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;handleSegment error: ${e.message}&quot;, e)&#10;                return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, &quot;text/plain&quot;, &quot;segment error: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.norwedish.twitchchatapp&#13;&#10;&#13;&#10;/**&#13;&#10; * Local HTTP proxy used to rewrite Twitch HLS playlists so receivers (Cast) can access segments via LAN.&#13;&#10; * This module implements a tiny embedded server and playlist/segment rewrites.&#13;&#10; */&#13;&#10;&#13;&#10;import android.util.Log&#13;&#10;import kotlinx.coroutines.CoroutineScope&#13;&#10;import kotlinx.coroutines.Dispatchers&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.withContext&#13;&#10;import fi.iki.elonen.NanoHTTPD&#13;&#10;import java.io.InputStream&#13;&#10;import java.net.HttpURLConnection&#13;&#10;import java.net.URL&#13;&#10;import java.net.URLEncoder&#13;&#10;import java.net.InetAddress&#13;&#10;import java.net.NetworkInterface&#13;&#10;&#13;&#10;object LocalProxyServer {&#13;&#10;    private const val TAG = &quot;LocalProxyServer&quot;&#13;&#10;    private var server: NanoProxy? = null&#13;&#10;    private var port: Int = 0&#13;&#10;    private var baseUrlCache: String? = null&#13;&#10;    // Diagnostics&#13;&#10;    @Volatile&#13;&#10;    var lastPlaylistRequested: String? = null&#13;&#10;        private set&#13;&#10;    @Volatile&#13;&#10;    var segmentRequestCount: Int = 0&#13;&#10;        private set&#13;&#10;    @Volatile&#13;&#10;    var lastSegmentStatus: Int? = null&#13;&#10;        private set&#13;&#10;&#13;&#10;    // Start the local proxy on an automatically chosen free port.&#13;&#10;    // onStarted(baseUrl) will be invoked on the main thread with a reachable base URL (http://&lt;device-ip&gt;:port)&#13;&#10;    fun start(onStarted: ((baseUrl: String) -&gt; Unit)? = null) {&#13;&#10;        if (server != null) {&#13;&#10;            onStarted?.invoke(getBaseUrl())&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        CoroutineScope(Dispatchers.IO).launch {&#13;&#10;            try {&#13;&#10;                val s = NanoProxy(0)&#13;&#10;                s.start(NanoHTTPD.SOCKET_READ_TIMEOUT, false)&#13;&#10;                server = s&#13;&#10;                port = s.listeningPort&#13;&#10;&#13;&#10;                // Determine a LAN-reachable IP address to present to Chromecast&#13;&#10;                val ip = findLocalIpAddress() ?: &quot;127.0.0.1&quot;&#13;&#10;                baseUrlCache = &quot;http://$ip:$port&quot;&#13;&#10;&#13;&#10;                val base = baseUrlCache ?: &quot;&quot;&#13;&#10;                Log.i(TAG, &quot;Local proxy started at $base&quot;)&#13;&#10;                withContext(Dispatchers.Main) {&#13;&#10;                    onStarted?.invoke(base)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(TAG, &quot;Failed to start local proxy: ${e.message}&quot;, e)&#13;&#10;                withContext(Dispatchers.Main) {&#13;&#10;                    onStarted?.invoke(&quot;&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun stop() {&#13;&#10;        try {&#13;&#10;            server?.stop()&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.w(TAG, &quot;Error stopping local proxy: ${e.message}&quot;)&#13;&#10;        }&#13;&#10;        server = null&#13;&#10;        port = 0&#13;&#10;        baseUrlCache = null&#13;&#10;    }&#13;&#10;&#13;&#10;    fun isRunning(): Boolean = server != null&#13;&#10;&#13;&#10;    fun getBaseUrl(): String = baseUrlCache ?: &quot;http://127.0.0.1:${port}&quot;&#13;&#10;&#13;&#10;    fun localPlaylistUrlFor(remoteM3u8: String): String {&#13;&#10;        // Ensure server is started asynchronously if not running&#13;&#10;        if (!isRunning()) start()&#13;&#10;        val encoded = URLEncoder.encode(remoteM3u8, &quot;UTF-8&quot;)&#13;&#10;        return &quot;${getBaseUrl()}/stream?source=$encoded&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun findLocalIpAddress(): String? {&#13;&#10;        try {&#13;&#10;            val interfaces = NetworkInterface.getNetworkInterfaces()&#13;&#10;            for (intf in interfaces) {&#13;&#10;                val addrs = intf.inetAddresses&#13;&#10;                for (addr in addrs) {&#13;&#10;                    if (!addr.isLoopbackAddress &amp;&amp; addr is InetAddress) {&#13;&#10;                        val host = addr.hostAddress&#13;&#10;                        // prefer IPv4&#13;&#10;                        if (host.indexOf(':') &lt; 0) {&#13;&#10;                            return host&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.w(TAG, &quot;Failed to enumerate network interfaces: ${e.message}&quot;)&#13;&#10;        }&#13;&#10;        return null&#13;&#10;    }&#13;&#10;&#13;&#10;    private class NanoProxy(port: Int) : NanoHTTPD(port) {&#13;&#10;        override fun serve(session: IHTTPSession): Response {&#13;&#10;            val uri = session.uri&#13;&#10;            return try {&#13;&#10;                if (uri == &quot;/status&quot;) {&#13;&#10;                    val body = &quot;lastPlaylist=${lastPlaylistRequested ?: &quot;&lt;none&gt;&quot;}\nsegmentRequests=$segmentRequestCount\nlastSegmentStatus=${lastSegmentStatus ?: &quot;&lt;none&gt;&quot;}\n&quot;&#13;&#10;                    return newFixedLengthResponse(Response.Status.OK, &quot;text/plain&quot;, body)&#13;&#10;                }&#13;&#10;                when (uri) {&#13;&#10;                    &quot;/stream&quot; -&gt; handleStream(session)&#13;&#10;                    &quot;/segment&quot; -&gt; handleSegment(session)&#13;&#10;                    else -&gt; newFixedLengthResponse(Response.Status.OK, &quot;text/plain&quot;, &quot;LocalProxy running&quot;)&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(TAG, &quot;NanoProxy serve error: ${e.message}&quot;, e)&#13;&#10;                newFixedLengthResponse(Response.Status.INTERNAL_ERROR, &quot;text/plain&quot;, &quot;proxy error: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        private fun handleStream(session: IHTTPSession): Response {&#13;&#10;            val params = session.parameters&#13;&#10;            val src = params[&quot;source&quot;]?.firstOrNull() ?: return newFixedLengthResponse(Response.Status.BAD_REQUEST, &quot;text/plain&quot;, &quot;missing source&quot;)&#13;&#10;            val remote = java.net.URL(java.net.URLDecoder.decode(src, &quot;UTF-8&quot;))&#13;&#10;&#13;&#10;            try {&#13;&#10;                Log.d(TAG, &quot;handleStream request for remote playlist: ${remote}&quot;)&#13;&#10;                lastPlaylistRequested = remote.toString()&#13;&#10;                val conn = remote.openConnection() as HttpURLConnection&#13;&#10;                conn.instanceFollowRedirects = true&#13;&#10;                // Use a browser-like User-Agent to increase acceptance by remote servers (Twitch sometimes blocks non-browser UAs)&#13;&#10;                conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Android 10; Mobile; rv:115.0) Gecko/115.0 Firefox/115.0&quot;)&#13;&#10;                conn.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;)&#13;&#10;                conn.setRequestProperty(&quot;Referer&quot;, &quot;https://www.twitch.tv/&quot;)&#13;&#10;                conn.connectTimeout = 8000&#13;&#10;                conn.readTimeout = 15000&#13;&#10;                conn.connect()&#13;&#10;                val code = conn.responseCode&#13;&#10;                Log.d(TAG, &quot;Fetched remote playlist: ${remote} -&gt; HTTP $code&quot;)&#13;&#10;                if (code !in 200..299) {&#13;&#10;                    val msg = conn.responseMessage&#13;&#10;                    conn.disconnect()&#13;&#10;                    return newFixedLengthResponse(Response.Status.lookup(code), &quot;text/plain&quot;, &quot;fetch failed: $code $msg&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                val text = conn.inputStream.bufferedReader().use { it.readText() }&#13;&#10;                conn.disconnect()&#13;&#10;&#13;&#10;                // Rewrite URI lines&#13;&#10;                val base = remote&#13;&#10;                val hostHeader = session.headers[&quot;host&quot;]&#13;&#10;                val host = hostHeader ?: &quot;${findLocalIpAddress() ?: &quot;127.0.0.1&quot;}:$listeningPort&quot;&#13;&#10;                val prefix = &quot;http://$host&quot;&#13;&#10;&#13;&#10;                val rewritten = text.lines().joinToString(separator = &quot;\r\n&quot;) { line -&gt;&#13;&#10;                    val trim = line.trim()&#13;&#10;                    if (trim.isEmpty() || trim.startsWith(&quot;#&quot;)) return@joinToString line&#13;&#10;                    try {&#13;&#10;                        val resolved = URL(base, trim).toString()&#13;&#10;                        val enc = URLEncoder.encode(resolved, &quot;UTF-8&quot;)&#13;&#10;                        Log.d(TAG, &quot;Rewriting playlist line. original=$trim resolved=$resolved -&gt; $prefix/segment?u=$enc&quot;)&#13;&#10;                        &quot;$prefix/segment?u=$enc&quot;&#13;&#10;                    } catch (e: Exception) {&#13;&#10;                        line&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                // Use application/x-mpegURL which is commonly accepted for HLS playlists&#13;&#10;                val resp = newFixedLengthResponse(Response.Status.OK, &quot;application/x-mpegURL&quot;, rewritten)&#13;&#10;                resp.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)&#13;&#10;                resp.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Range,Content-Type&quot;)&#13;&#10;                Log.d(TAG, &quot;Returning rewritten playlist to client: ${session.remoteIpAddress}&quot;)&#13;&#10;                return resp&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(TAG, &quot;handleStream error: ${e.message}&quot;, e)&#13;&#10;                return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, &quot;text/plain&quot;, &quot;error: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        private fun handleSegment(session: IHTTPSession): Response {&#13;&#10;            val params = session.parameters&#13;&#10;            val enc = params[&quot;u&quot;]?.firstOrNull() ?: return newFixedLengthResponse(Response.Status.BAD_REQUEST, &quot;text/plain&quot;, &quot;missing u&quot;)&#13;&#10;            val remoteUrl = java.net.URL(java.net.URLDecoder.decode(enc, &quot;UTF-8&quot;))&#13;&#10;            try {&#13;&#10;                Log.d(TAG, &quot;handleSegment request for: $remoteUrl from ${session.remoteIpAddress}; headers=${session.headers}&quot;)&#13;&#10;                val conn = remoteUrl.openConnection() as HttpURLConnection&#13;&#10;                conn.instanceFollowRedirects = true&#13;&#10;                // Forward Range header if present&#13;&#10;                val range = session.headers[&quot;range&quot;]&#13;&#10;                if (!range.isNullOrEmpty()) conn.setRequestProperty(&quot;Range&quot;, range)&#13;&#10;                if (!range.isNullOrEmpty()) Log.d(TAG, &quot;Forwarding Range header to remote: $range&quot;)&#13;&#10;                // Use a browser-like User-Agent for segment requests as well&#13;&#10;                conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Android 10; Mobile; rv:115.0) Gecko/115.0 Firefox/115.0&quot;)&#13;&#10;                conn.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;)&#13;&#10;                conn.setRequestProperty(&quot;Referer&quot;, &quot;https://www.twitch.tv/&quot;)&#13;&#10;                conn.connectTimeout = 10000&#13;&#10;                conn.readTimeout = 20000&#13;&#10;                conn.connect()&#13;&#10;&#13;&#10;                val code = conn.responseCode&#13;&#10;                Log.d(TAG, &quot;Remote segment responded with HTTP $code for $remoteUrl&quot;)&#13;&#10;                // diagnostics&#13;&#10;                synchronized(this@LocalProxyServer) { segmentRequestCount++ }&#13;&#10;                lastSegmentStatus = code&#13;&#10;                val contentType = conn.contentType ?: &quot;application/octet-stream&quot;&#13;&#10;&#13;&#10;                // Read the remote response into memory so we can return a fixed-length response&#13;&#10;                val bytes = conn.inputStream.use { it.readBytes() }&#13;&#10;                val remoteContentLength = conn.getHeaderFieldInt(&quot;Content-Length&quot;, bytes.size)&#13;&#10;                Log.d(TAG, &quot;Remote Content-Length header: $remoteContentLength, buffered ${bytes.size} bytes&quot;)&#13;&#10;                val resp = newFixedLengthResponse(Response.Status.lookup(code), contentType, bytes.inputStream(), bytes.size.toLong())&#13;&#10;                // forward content-range/length if available&#13;&#10;                conn.headerFields[&quot;Content-Range&quot;]?.firstOrNull()?.let { resp.addHeader(&quot;Content-Range&quot;, it) }&#13;&#10;                conn.getHeaderField(&quot;Accept-Ranges&quot;)?.let { resp.addHeader(&quot;Accept-Ranges&quot;, it) }&#13;&#10;                // Ensure Content-Length is forwarded if available&#13;&#10;                try { resp.addHeader(&quot;Content-Length&quot;, bytes.size.toString()) } catch (_: Exception) {}&#13;&#10;                // CORS for clients that may enforce it&#13;&#10;                try { resp.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) } catch (_: Exception) {}&#13;&#10;                try { resp.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Range,Content-Type&quot;) } catch (_: Exception) {}&#13;&#10;                Log.d(TAG, &quot;Responding to client ${session.remoteIpAddress} with contentType=$contentType, code=$code&quot;)&#13;&#10;                return resp&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(TAG, &quot;handleSegment error: ${e.message}&quot;, e)&#13;&#10;                return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, &quot;text/plain&quot;, &quot;segment error: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/MainActivity.kt" />
              <option name="originalContent" value="package com.norwedish.twitchchatapp&#10;&#10;/**&#10; * Main entry points for the app UI and navigation.&#10; *&#10; * This file contains the app routes, the main activity that bootstraps the Compose UI,&#10; * and the top-level composable that displays the main screen, routing and splash/loading states.&#10; */&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.content.BroadcastReceiver&#10;import android.content.ComponentName&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.view.WindowManager&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.viewModels&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ChatBubble&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.Badge&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.WindowCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import androidx.work.*&#10;import coil.compose.AsyncImage&#10;import com.norwedish.twitchchatapp.ui.theme.TwitchChatAppTheme&#10;import kotlinx.coroutines.launch&#10;import java.net.URLDecoder&#10;import java.net.URLEncoder&#10;import java.util.concurrent.TimeUnit&#10;import androidx.compose.material3.pulltorefresh.PullToRefreshBox&#10;import java.util.Locale&#10;&#10;/**&#10; * Simple object that centralizes route names used by the app's NavHost.&#10; */&#10;object AppRoutes {&#10;    const val LOGIN = &quot;login&quot;&#10;    const val MAIN = &quot;main&quot;&#10;    const val SEARCH = &quot;search&quot;&#10;    const val SETTINGS = &quot;settings&quot;&#10;    const val CHAT = &quot;chat/{channelName}/{twitchUserId}/{displayName}/{profileImageUrl}&quot;&#10;&#10;    fun chatRoute(channelName: String, twitchUserId: String, displayName: String, profileImageUrl: String): String {&#10;        val encodedUrl = URLEncoder.encode(profileImageUrl, &quot;UTF-8&quot;)&#10;        return &quot;chat/$channelName/$twitchUserId/$displayName/$encodedUrl&quot;&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;/**&#10; * The Activity that starts the Compose UI, registers background receivers, and schedules periodic work.&#10; * It wires up navigation and handles permission requests and lifecycle events for global app concerns.&#10; */&#10;class MainActivity : AppCompatActivity() {&#10;    private val mainViewModel: MainViewModel by viewModels()&#10;&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { _ -&gt;&#10;        // Handle the permission result if needed&#10;    }&#10;&#10;    private val streamUpReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            if (intent?.action == LiveStreamWorker.ACTION_STREAM_UP) {&#10;                mainViewModel.loadFollowedStreams()&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;UnspecifiedRegisterReceiverFlag&quot;)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        WindowCompat.setDecorFitsSystemWindows(window, false)&#10;        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;&#10;        askNotificationPermission()&#10;&#10;        if (UserManager.accessToken != null) {&#10;            scheduleLiveStreamWorker()&#10;        }&#10;&#10;        val intentFilter = IntentFilter(LiveStreamWorker.ACTION_STREAM_UP)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            registerReceiver(streamUpReceiver, intentFilter, RECEIVER_NOT_EXPORTED)&#10;        } else {&#10;            registerReceiver(streamUpReceiver, intentFilter)&#10;        }&#10;&#10;        setContent {&#10;            TwitchChatAppTheme {&#10;                val navController = rememberNavController()&#10;                val scope = rememberCoroutineScope()&#10;&#10;                if (UserManager.isLoading) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                } else {&#10;                    NavHost(&#10;                        navController = navController,&#10;                        startDestination = if (UserManager.accessToken == null) AppRoutes.LOGIN else AppRoutes.MAIN&#10;                    ) {&#10;                        composable(AppRoutes.LOGIN) {&#10;                            LoginScreen(onLoginSuccess = { token -&gt;&#10;                                lifecycleScope.launch {&#10;                                    val user = TwitchApi.getCurrentUser(token, UserManager.CLIENT_ID)&#10;                                    if (user != null) {&#10;                                        UserManager.login(token, user)&#10;                                        scheduleLiveStreamWorker()&#10;                                        navController.navigate(AppRoutes.MAIN) {&#10;                                            popUpTo(AppRoutes.LOGIN) { inclusive = true }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            })&#10;                        }&#10;&#10;                        composable(AppRoutes.MAIN) {&#10;                            LaunchedEffect(Unit) {&#10;                                mainViewModel.loadFollowedStreams()&#10;                            }&#10;                            MainScreen(&#10;                                 viewModel = mainViewModel,&#10;                                 onStreamClick = { enrichedStream -&gt;&#10;                                     navController.navigate(&#10;                                         AppRoutes.chatRoute(&#10;                                             channelName = enrichedStream.stream.userLogin,&#10;                                             twitchUserId = enrichedStream.stream.userId,&#10;                                             displayName = enrichedStream.user.displayName,&#10;                                             profileImageUrl = enrichedStream.user.profileImageUrl&#10;                                         )&#10;                                     )&#10;                                 },&#10;                                 onSearchClick = { navController.navigate(AppRoutes.SEARCH) },&#10;                                 onLogoutClick = {&#10;                                     scope.launch {&#10;                                         UserManager.logout()&#10;                                         cancelLiveStreamWorker()&#10;                                         navController.navigate(AppRoutes.LOGIN) {&#10;                                             popUpTo(AppRoutes.MAIN) { inclusive = true }&#10;                                         }&#10;                                     }&#10;                                 },&#10;                                 onSettingsClick = { navController.navigate(AppRoutes.SETTINGS) }&#10;                                 )&#10;                             }&#10;                        composable(AppRoutes.SETTINGS) {&#10;                            ChatSettingsScreen(onNavigateBack = { navController.popBackStack() })&#10;                        }&#10;&#10;                        composable(&#10;                            route = AppRoutes.CHAT,&#10;                            arguments = listOf(&#10;                                navArgument(&quot;channelName&quot;) { type = NavType.StringType },&#10;                                navArgument(&quot;twitchUserId&quot;) { type = NavType.StringType },&#10;                                navArgument(&quot;displayName&quot;) { type = NavType.StringType },&#10;                                navArgument(&quot;profileImageUrl&quot;) { type = NavType.StringType }&#10;                            )&#10;                        ) { backStackEntry -&gt;&#10;                            val channelName = backStackEntry.arguments?.getString(&quot;channelName&quot;) ?: &quot;&quot;&#10;                            val twitchUserId = backStackEntry.arguments?.getString(&quot;twitchUserId&quot;) ?: &quot;&quot;&#10;                            val displayName = backStackEntry.arguments?.getString(&quot;displayName&quot;) ?: &quot;&quot;&#10;                            val profileImageUrl = backStackEntry.arguments?.getString(&quot;profileImageUrl&quot;)?.let {&#10;                                URLDecoder.decode(it, &quot;UTF-8&quot;)&#10;                            } ?: &quot;&quot;&#10;&#10;                            ChatScreen(&#10;                                channelName = channelName,&#10;                                twitchUserId = twitchUserId,&#10;                                displayName = displayName,&#10;                                profileImageUrl = profileImageUrl,&#10;                                viewModel = viewModel(),&#10;                                onNavigateBack = { navController.popBackStack() }&#10;                            )&#10;                        }&#10;&#10;                        composable(AppRoutes.SEARCH) {&#10;                            SearchScreen(&#10;                                onNavigateToChat = { channel -&gt;&#10;                                    navController.navigate(&#10;                                        AppRoutes.chatRoute(&#10;                                            channelName = channel.broadcasterLogin,&#10;                                            twitchUserId = channel.id,&#10;                                            displayName = channel.displayName,&#10;                                            profileImageUrl = channel.thumbnailUrl&#10;                                        )&#10;                                    )&#10;                                },&#10;                                onNavigateBack = { navController.popBackStack() }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        unregisterReceiver(streamUpReceiver)&#10;    }&#10;&#10;    private fun scheduleLiveStreamWorker() {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.CONNECTED)&#10;            .build()&#10;&#10;        val periodicWorkRequest = PeriodicWorkRequestBuilder&lt;LiveStreamWorker&gt;(&#10;            15, TimeUnit.MINUTES&#10;        )&#10;            .setConstraints(constraints)&#10;            .build()&#10;&#10;        WorkManager.getInstance(this).enqueueUniquePeriodicWork(&#10;            LiveStreamWorker.WORK_NAME,&#10;            ExistingPeriodicWorkPolicy.REPLACE,&#10;            periodicWorkRequest&#10;        )&#10;    }&#10;&#10;    private fun cancelLiveStreamWorker() {&#10;        WorkManager.getInstance(this).cancelUniqueWork(LiveStreamWorker.WORK_NAME)&#10;    }&#10;&#10;    private fun askNotificationPermission() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) !=&#10;                PackageManager.PERMISSION_GRANTED) {&#10;                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;/**&#10; * The main screen composable that aggregates the home UI: stream list, app bar and navigation actions.&#10; * It obtains state from the provided MainViewModel and exposes callbacks for navigation and actions.&#10; */&#10;@Composable&#10;fun MainScreen(&#10;    viewModel: MainViewModel,&#10;    onStreamClick: (EnrichedStream) -&gt; Unit,&#10;    onSearchClick: () -&gt; Unit,&#10;    onLogoutClick: () -&gt; Unit,&#10;    onSettingsClick: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val streams by viewModel.followedStreams&#10;    val isLoading by viewModel.isLoading&#10;    val currentUser = UserManager.currentUser&#10;    var menuExpanded by remember { mutableStateOf(false) }&#10;&#10;    // Whisper system integration&#10;    val whisperViewModel: WhisperViewModel = viewModel()&#10;    var showWhisperScreen by remember { mutableStateOf(false) }&#10;&#10;    // Initialize whisper view model and service&#10;    DisposableEffect(Unit) {&#10;        val prefManager = WhisperPreferenceManager(context)&#10;        val user = UserManager.currentUser&#10;        if (user != null) {&#10;            whisperViewModel.initialize(prefManager, user.id, user.login)&#10;        }&#10;&#10;        val whisperServiceIntent = Intent(context, WhisperService::class.java)&#10;        context.startService(whisperServiceIntent)&#10;&#10;        val whisperServiceConnection = object : ServiceConnection {&#10;            override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;                val binder = service as WhisperService.WhisperBinder&#10;                whisperViewModel.setWhisperService(binder.getService())&#10;            }&#10;&#10;            override fun onServiceDisconnected(name: ComponentName?) {}&#10;        }&#10;&#10;        context.bindService(whisperServiceIntent, whisperServiceConnection, Context.BIND_AUTO_CREATE)&#10;&#10;        onDispose {&#10;            context.unbindService(whisperServiceConnection)&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.logo),&#10;                            contentDescription = &quot;App Logo&quot;,&#10;                            modifier = Modifier.size(40.dp),&#10;                            contentScale = ContentScale.Fit&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Column {&#10;                            Text(text = &quot;Twitch Chat App&quot;, style = MaterialTheme.typography.titleLarge)&#10;                            if (currentUser != null) {&#10;                                Row(&#10;                                    modifier = Modifier.clickable { menuExpanded = true },&#10;                                    verticalAlignment = Alignment.CenterVertically,&#10;                                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    AsyncImage(&#10;                                        model = currentUser.profileImageUrl,&#10;                                        contentDescription = &quot;User Avatar&quot;,&#10;                                        modifier = Modifier.size(24.dp).clip(CircleShape),&#10;                                        contentScale = ContentScale.Crop&#10;                                    )&#10;                                    Text(&#10;                                        text = currentUser.displayName,&#10;                                        style = MaterialTheme.typography.titleSmall&#10;                                    )&#10;                                    DropdownMenu(expanded = menuExpanded, onDismissRequest = { menuExpanded = false }) {&#10;                                        DropdownMenuItem(&#10;                                            text = { Text(&quot;Log Out&quot;) },&#10;                                            onClick = {&#10;                                                menuExpanded = false&#10;                                                onLogoutClick()&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                actions = {&#10;                    val totalUnreadWhispers by whisperViewModel.totalUnreadCount.collectAsState()&#10;                    IconButton(onClick = {&#10;                        // Open the full whisper screen directly&#10;                        showWhisperScreen = true&#10;                    }) {&#10;                        Box {&#10;                            Icon(Icons.Default.ChatBubble, contentDescription = &quot;Messages&quot;)&#10;                            if (totalUnreadWhispers &gt; 0) {&#10;                                Badge(&#10;                                    modifier = Modifier.align(Alignment.TopEnd),&#10;                                    containerColor = MaterialTheme.colorScheme.error&#10;                                ) {&#10;                                    Text(&#10;                                        totalUnreadWhispers.toString(),&#10;                                        color = MaterialTheme.colorScheme.onError,&#10;                                        fontSize = 10.sp&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    IconButton(onClick = onSettingsClick) {&#10;                        Icon(Icons.Default.Settings, contentDescription = &quot;Settings&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = onSearchClick) {&#10;                Icon(Icons.Default.Search, contentDescription = &quot;Search for a streamer&quot;)&#10;            }&#10;        }&#10;    ) { paddingValues -&gt;&#10;        PullToRefreshBox(&#10;            isRefreshing = isLoading,&#10;            onRefresh = { viewModel.loadFollowedStreams() },&#10;            modifier = Modifier.padding(paddingValues)&#10;        ) {&#10;            if (streams.isEmpty() &amp;&amp; !isLoading) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp)&#10;                        .verticalScroll(rememberScrollState()),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;No followed channels are currently live. Pull down to refresh.&quot;,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentPadding = PaddingValues(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    items(streams, key = { it.stream.id }) { stream -&gt;&#10;                        StreamCard(&#10;                            stream = stream,&#10;                            onClick = { onStreamClick(stream) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Whisper Screen (full screen view)&#10;    if (showWhisperScreen) {&#10;        WhisperScreen(&#10;            viewModel = whisperViewModel,&#10;            onNavigateBack = { showWhisperScreen = false }&#10;        )&#10;    }&#10;}&#10;&#10;private fun formatViewerCount(count: Int): String {&#10;    return when {&#10;        count &gt;= 1_000_000 -&gt; String.format(Locale.ROOT, &quot;%.1fM&quot;, count / 1_000_000f)&#10;        count &gt;= 1_000 -&gt; String.format(Locale.ROOT, &quot;%.1fK&quot;, count / 1_000f)&#10;        else -&gt; count.toString()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun StreamCard(stream: EnrichedStream, onClick: () -&gt; Unit) {&#10;    Card(&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        onClick = onClick,&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Row(modifier = Modifier.padding(16.dp), verticalAlignment = Alignment.Top) {&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                AsyncImage(&#10;                    model = stream.user.profileImageUrl,&#10;                    contentDescription = &quot;Streamer avatar&quot;,&#10;                    modifier = Modifier&#10;                        .size(40.dp)&#10;                        .clip(CircleShape),&#10;                    contentScale = ContentScale.Crop&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Person,&#10;                        contentDescription = &quot;Viewers&quot;,&#10;                        modifier = Modifier.size(16.dp),&#10;                        tint = Color.Red&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = formatViewerCount(stream.stream.viewerCount),&#10;                        fontSize = 12.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            Column {&#10;                Text(&#10;                    text = stream.user.displayName,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 20.sp&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = stream.stream.title,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = stream.stream.gameName,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.norwedish.twitchchatapp&#10;&#10;/**&#10; * App entry point Activity which hosts the Compose navigation graph.&#10; * Responsible for wiring top-level UI, handling deep links, and managing Cast initialization.&#10; */&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.content.BroadcastReceiver&#10;import android.content.ComponentName&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.view.WindowManager&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.viewModels&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.PaddingValues&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ChatBubble&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.Badge&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.DropdownMenu&#10;import androidx.compose.material3.DropdownMenuItem&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.DisposableEffect&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.WindowCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import androidx.work.*&#10;import coil.compose.AsyncImage&#10;import com.norwedish.twitchchatapp.ui.theme.TwitchChatAppTheme&#10;import kotlinx.coroutines.launch&#10;import java.net.URLDecoder&#10;import java.net.URLEncoder&#10;import java.util.concurrent.TimeUnit&#10;import androidx.compose.material3.pulltorefresh.PullToRefreshBox&#10;import java.util.Locale&#10;&#10;/**&#10; * Simple object that centralizes route names used by the app's NavHost.&#10; */&#10;object AppRoutes {&#10;    const val LOGIN = &quot;login&quot;&#10;    const val MAIN = &quot;main&quot;&#10;    const val SEARCH = &quot;search&quot;&#10;    const val SETTINGS = &quot;settings&quot;&#10;    const val CHAT = &quot;chat/{channelName}/{twitchUserId}/{displayName}/{profileImageUrl}&quot;&#10;&#10;    fun chatRoute(channelName: String, twitchUserId: String, displayName: String, profileImageUrl: String): String {&#10;        val encodedUrl = URLEncoder.encode(profileImageUrl, &quot;UTF-8&quot;)&#10;        return &quot;chat/$channelName/$twitchUserId/$displayName/$encodedUrl&quot;&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;/**&#10; * The Activity that starts the Compose UI, registers background receivers, and schedules periodic work.&#10; * It wires up navigation and handles permission requests and lifecycle events for global app concerns.&#10; */&#10;class MainActivity : AppCompatActivity() {&#10;    private val mainViewModel: MainViewModel by viewModels()&#10;&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { _ -&gt;&#10;        // Handle the permission result if needed&#10;    }&#10;&#10;    private val streamUpReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            if (intent?.action == LiveStreamWorker.ACTION_STREAM_UP) {&#10;                mainViewModel.loadFollowedStreams()&#10;            }&#10;        }&#10;    }&#10;&#10;    @SuppressLint(&quot;UnspecifiedRegisterReceiverFlag&quot;)&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        WindowCompat.setDecorFitsSystemWindows(window, false)&#10;        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)&#10;&#10;        askNotificationPermission()&#10;&#10;        if (UserManager.accessToken != null) {&#10;            scheduleLiveStreamWorker()&#10;        }&#10;&#10;        val intentFilter = IntentFilter(LiveStreamWorker.ACTION_STREAM_UP)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            registerReceiver(streamUpReceiver, intentFilter, RECEIVER_NOT_EXPORTED)&#10;        } else {&#10;            registerReceiver(streamUpReceiver, intentFilter)&#10;        }&#10;&#10;        setContent {&#10;            TwitchChatAppTheme {&#10;                val navController = rememberNavController()&#10;                val scope = rememberCoroutineScope()&#10;&#10;                if (UserManager.isLoading) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                } else {&#10;                    NavHost(&#10;                        navController = navController,&#10;                        startDestination = if (UserManager.accessToken == null) AppRoutes.LOGIN else AppRoutes.MAIN&#10;                    ) {&#10;                        composable(AppRoutes.LOGIN) {&#10;                            LoginScreen(onLoginSuccess = { token -&gt;&#10;                                lifecycleScope.launch {&#10;                                    val user = TwitchApi.getCurrentUser(token, UserManager.CLIENT_ID)&#10;                                    if (user != null) {&#10;                                        UserManager.login(token, user)&#10;                                        scheduleLiveStreamWorker()&#10;                                        navController.navigate(AppRoutes.MAIN) {&#10;                                            popUpTo(AppRoutes.LOGIN) { inclusive = true }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            })&#10;                        }&#10;&#10;                        composable(AppRoutes.MAIN) {&#10;                            LaunchedEffect(Unit) {&#10;                                mainViewModel.loadFollowedStreams()&#10;                            }&#10;                            MainScreen(&#10;                                 viewModel = mainViewModel,&#10;                                 onStreamClick = { enrichedStream -&gt;&#10;                                     navController.navigate(&#10;                                         AppRoutes.chatRoute(&#10;                                             channelName = enrichedStream.stream.userLogin,&#10;                                             twitchUserId = enrichedStream.stream.userId,&#10;                                             displayName = enrichedStream.user.displayName,&#10;                                             profileImageUrl = enrichedStream.user.profileImageUrl&#10;                                         )&#10;                                     )&#10;                                 },&#10;                                 onSearchClick = { navController.navigate(AppRoutes.SEARCH) },&#10;                                 onLogoutClick = {&#10;                                     scope.launch {&#10;                                         UserManager.logout()&#10;                                         cancelLiveStreamWorker()&#10;                                         navController.navigate(AppRoutes.LOGIN) {&#10;                                             popUpTo(AppRoutes.MAIN) { inclusive = true }&#10;                                         }&#10;                                     }&#10;                                 },&#10;                                 onSettingsClick = { navController.navigate(AppRoutes.SETTINGS) }&#10;                                 )&#10;                             }&#10;                        composable(AppRoutes.SETTINGS) {&#10;                            ChatSettingsScreen(onNavigateBack = { navController.popBackStack() })&#10;                        }&#10;&#10;                        composable(&#10;                            route = AppRoutes.CHAT,&#10;                            arguments = listOf(&#10;                                navArgument(&quot;channelName&quot;) { type = NavType.StringType },&#10;                                navArgument(&quot;twitchUserId&quot;) { type = NavType.StringType },&#10;                                navArgument(&quot;displayName&quot;) { type = NavType.StringType },&#10;                                navArgument(&quot;profileImageUrl&quot;) { type = NavType.StringType }&#10;                            )&#10;                        ) { backStackEntry -&gt;&#10;                            val channelName = backStackEntry.arguments?.getString(&quot;channelName&quot;) ?: &quot;&quot;&#10;                            val twitchUserId = backStackEntry.arguments?.getString(&quot;twitchUserId&quot;) ?: &quot;&quot;&#10;                            val displayName = backStackEntry.arguments?.getString(&quot;displayName&quot;) ?: &quot;&quot;&#10;                            val profileImageUrl = backStackEntry.arguments?.getString(&quot;profileImageUrl&quot;)?.let {&#10;                                URLDecoder.decode(it, &quot;UTF-8&quot;)&#10;                            } ?: &quot;&quot;&#10;&#10;                            ChatScreen(&#10;                                channelName = channelName,&#10;                                twitchUserId = twitchUserId,&#10;                                displayName = displayName,&#10;                                profileImageUrl = profileImageUrl,&#10;                                viewModel = viewModel(),&#10;                                onNavigateBack = { navController.popBackStack() }&#10;                            )&#10;                        }&#10;&#10;                        composable(AppRoutes.SEARCH) {&#10;                            SearchScreen(&#10;                                onNavigateToChat = { channel -&gt;&#10;                                    navController.navigate(&#10;                                        AppRoutes.chatRoute(&#10;                                            channelName = channel.broadcasterLogin,&#10;                                            twitchUserId = channel.id,&#10;                                            displayName = channel.displayName,&#10;                                            profileImageUrl = channel.thumbnailUrl&#10;                                        )&#10;                                    )&#10;                                },&#10;                                onNavigateBack = { navController.popBackStack() }&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        unregisterReceiver(streamUpReceiver)&#10;    }&#10;&#10;    private fun scheduleLiveStreamWorker() {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.CONNECTED)&#10;            .build()&#10;&#10;        val periodicWorkRequest = PeriodicWorkRequestBuilder&lt;LiveStreamWorker&gt;(&#10;            15, TimeUnit.MINUTES&#10;        )&#10;            .setConstraints(constraints)&#10;            .build()&#10;&#10;        WorkManager.getInstance(this).enqueueUniquePeriodicWork(&#10;            LiveStreamWorker.WORK_NAME,&#10;            ExistingPeriodicWorkPolicy.REPLACE,&#10;            periodicWorkRequest&#10;        )&#10;    }&#10;&#10;    private fun cancelLiveStreamWorker() {&#10;        WorkManager.getInstance(this).cancelUniqueWork(LiveStreamWorker.WORK_NAME)&#10;    }&#10;&#10;    private fun askNotificationPermission() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) !=&#10;                PackageManager.PERMISSION_GRANTED) {&#10;                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;/**&#10; * The main screen composable that aggregates the home UI: stream list, app bar and navigation actions.&#10; * It obtains state from the provided MainViewModel and exposes callbacks for navigation and actions.&#10; */&#10;@Composable&#10;fun MainScreen(&#10;    viewModel: MainViewModel,&#10;    onStreamClick: (EnrichedStream) -&gt; Unit,&#10;    onSearchClick: () -&gt; Unit,&#10;    onLogoutClick: () -&gt; Unit,&#10;    onSettingsClick: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val streams by viewModel.followedStreams&#10;    val isLoading by viewModel.isLoading&#10;    val currentUser = UserManager.currentUser&#10;    var menuExpanded by remember { mutableStateOf(false) }&#10;&#10;    // Whisper system integration&#10;    val whisperViewModel: WhisperViewModel = viewModel()&#10;    var showWhisperScreen by remember { mutableStateOf(false) }&#10;&#10;    // Initialize whisper view model and service&#10;    DisposableEffect(Unit) {&#10;        val prefManager = WhisperPreferenceManager(context)&#10;        val user = UserManager.currentUser&#10;        if (user != null) {&#10;            whisperViewModel.initialize(prefManager, user.id, user.login)&#10;        }&#10;&#10;        val whisperServiceIntent = Intent(context, WhisperService::class.java)&#10;        context.startService(whisperServiceIntent)&#10;&#10;        val whisperServiceConnection = object : ServiceConnection {&#10;            override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;                val binder = service as WhisperService.WhisperBinder&#10;                whisperViewModel.setWhisperService(binder.getService())&#10;            }&#10;&#10;            override fun onServiceDisconnected(name: ComponentName?) {}&#10;        }&#10;&#10;        context.bindService(whisperServiceIntent, whisperServiceConnection, Context.BIND_AUTO_CREATE)&#10;&#10;        onDispose {&#10;            context.unbindService(whisperServiceConnection)&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.logo),&#10;                            contentDescription = &quot;App Logo&quot;,&#10;                            modifier = Modifier.size(40.dp),&#10;                            contentScale = ContentScale.Fit&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Column {&#10;                            Text(text = &quot;Twitch Chat App&quot;, style = MaterialTheme.typography.titleLarge)&#10;                            if (currentUser != null) {&#10;                                Row(&#10;                                    modifier = Modifier.clickable { menuExpanded = true },&#10;                                    verticalAlignment = Alignment.CenterVertically,&#10;                                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    AsyncImage(&#10;                                        model = currentUser.profileImageUrl,&#10;                                        contentDescription = &quot;User Avatar&quot;,&#10;                                        modifier = Modifier.size(24.dp).clip(CircleShape),&#10;                                        contentScale = ContentScale.Crop&#10;                                    )&#10;                                    Text(&#10;                                        text = currentUser.displayName,&#10;                                        style = MaterialTheme.typography.titleSmall&#10;                                    )&#10;                                    DropdownMenu(expanded = menuExpanded, onDismissRequest = { menuExpanded = false }) {&#10;                                        DropdownMenuItem(&#10;                                            text = { Text(&quot;Log Out&quot;) },&#10;                                            onClick = {&#10;                                                menuExpanded = false&#10;                                                onLogoutClick()&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                actions = {&#10;                    val totalUnreadWhispers by whisperViewModel.totalUnreadCount.collectAsState()&#10;                    IconButton(onClick = {&#10;                        // Open the full whisper screen directly&#10;                        showWhisperScreen = true&#10;                    }) {&#10;                        Box {&#10;                            Icon(Icons.Default.ChatBubble, contentDescription = &quot;Messages&quot;)&#10;                            if (totalUnreadWhispers &gt; 0) {&#10;                                Badge(&#10;                                    modifier = Modifier.align(Alignment.TopEnd),&#10;                                    containerColor = MaterialTheme.colorScheme.error&#10;                                ) {&#10;                                    Text(&#10;                                        totalUnreadWhispers.toString(),&#10;                                        color = MaterialTheme.colorScheme.onError,&#10;                                        fontSize = 10.sp&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                    IconButton(onClick = onSettingsClick) {&#10;                        Icon(Icons.Default.Settings, contentDescription = &quot;Settings&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            FloatingActionButton(onClick = onSearchClick) {&#10;                Icon(Icons.Default.Search, contentDescription = &quot;Search for a streamer&quot;)&#10;            }&#10;        }&#10;    ) { paddingValues -&gt;&#10;        PullToRefreshBox(&#10;            isRefreshing = isLoading,&#10;            onRefresh = { viewModel.loadFollowedStreams() },&#10;            modifier = Modifier.padding(paddingValues)&#10;        ) {&#10;            if (streams.isEmpty() &amp;&amp; !isLoading) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp)&#10;                        .verticalScroll(rememberScrollState()),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;No followed channels are currently live. Pull down to refresh.&quot;,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentPadding = PaddingValues(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    items(streams, key = { it.stream.id }) { stream -&gt;&#10;                        StreamCard(&#10;                            stream = stream,&#10;                            onClick = { onStreamClick(stream) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Whisper Screen (full screen view)&#10;    if (showWhisperScreen) {&#10;        WhisperScreen(&#10;            viewModel = whisperViewModel,&#10;            onNavigateBack = { showWhisperScreen = false }&#10;        )&#10;    }&#10;}&#10;&#10;private fun formatViewerCount(count: Int): String {&#10;    return when {&#10;        count &gt;= 1_000_000 -&gt; String.format(Locale.ROOT, &quot;%.1fM&quot;, count / 1_000_000f)&#10;        count &gt;= 1_000 -&gt; String.format(Locale.ROOT, &quot;%.1fK&quot;, count / 1_000f)&#10;        else -&gt; count.toString()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun StreamCard(stream: EnrichedStream, onClick: () -&gt; Unit) {&#10;    Card(&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),&#10;        onClick = onClick,&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Row(modifier = Modifier.padding(16.dp), verticalAlignment = Alignment.Top) {&#10;            Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                AsyncImage(&#10;                    model = stream.user.profileImageUrl,&#10;                    contentDescription = &quot;Streamer avatar&quot;,&#10;                    modifier = Modifier&#10;                        .size(40.dp)&#10;                        .clip(CircleShape),&#10;                    contentScale = ContentScale.Crop&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Row(verticalAlignment = Alignment.CenterVertically) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Person,&#10;                        contentDescription = &quot;Viewers&quot;,&#10;                        modifier = Modifier.size(16.dp),&#10;                        tint = Color.Red&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = formatViewerCount(stream.stream.viewerCount),&#10;                        fontSize = 12.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;            }&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;            Column {&#10;                Text(&#10;                    text = stream.user.displayName,&#10;                    fontWeight = FontWeight.Bold,&#10;                    fontSize = 20.sp&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = stream.stream.title,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                Text(&#10;                    text = stream.stream.gameName,&#10;                    fontSize = 14.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/MyApplication.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/norwedish/twitchchatapp/MyApplication.kt" />
              <option name="originalContent" value="package com.norwedish.twitchchatapp&#10;&#10;/**&#10; * Application class that performs global initialization.&#10; *&#10; * Responsibilities:&#10; * - Initialize UserManager and other global singletons&#10; * - Create notification channels used by background services&#10; * - Provide a Coil ImageLoader with memory and disk caching for the app&#10; */&#10;&#10;import android.app.Application&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.content.Context&#10;import android.os.Build&#10;import coil.ImageLoader&#10;import coil.ImageLoaderFactory&#10;import coil.decode.ImageDecoderDecoder&#10;import coil.disk.DiskCache&#10;import coil.memory.MemoryCache&#10;&#10;class MyApplication : Application(), ImageLoaderFactory {&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        // Initialiseer de UserManager zodra de app start&#10;        UserManager.init(this)&#10;        createNotificationChannel()&#10;        // Initialize CastManager so it's ready to handle casting requests&#10;        CastManager.initialize(this)&#10;    }&#10;&#10;    override fun newImageLoader(): ImageLoader {&#10;        return ImageLoader.Builder(this)&#10;            .memoryCache {&#10;                MemoryCache.Builder(this)&#10;                    .maxSizePercent(0.25)&#10;                    .build()&#10;            }&#10;&#10;            .diskCache {&#10;                DiskCache.Builder()&#10;                    .directory(this.cacheDir.resolve(&quot;image_cache&quot;))&#10;                    .maxSizePercent(0.02)&#10;                    .build()&#10;            }&#10;            .components {&#10;                if (Build.VERSION.SDK_INT &gt;= 28) {&#10;                    add(ImageDecoderDecoder.Factory())&#10;                } else {&#10;                    // Fallback for older API levels if needed&#10;                }&#10;            }&#10;            .build()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val name = &quot;Twitch Chat Service&quot;&#10;            val descriptionText = &quot;Notification channel for the chat service&quot;&#10;            val importance = NotificationManager.IMPORTANCE_LOW&#10;            val channel = NotificationChannel(ChatService.CHANNEL_ID, name, importance).apply {&#10;                description = descriptionText&#10;                // Ensure chat channel is silent by default&#10;                setSound(null, null)&#10;                enableVibration(false)&#10;            }&#10;            val notificationManager:&#10;                    NotificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.norwedish.twitchchatapp&#13;&#10;&#13;&#10;/**&#13;&#10; * Custom Application class where global init (UserManager, CastManager) occurs.&#13;&#10; *&#13;&#10; * Responsibilities:&#13;&#10; * - Initialize UserManager and other global singletons&#13;&#10; * - Create notification channels used by background services&#13;&#10; * - Provide a Coil ImageLoader with memory and disk caching for the app&#13;&#10; */&#13;&#10;&#13;&#10;import android.app.Application&#13;&#10;import android.app.NotificationChannel&#13;&#10;import android.app.NotificationManager&#13;&#10;import android.content.Context&#13;&#10;import android.os.Build&#13;&#10;import coil.ImageLoader&#13;&#10;import coil.ImageLoaderFactory&#13;&#10;import coil.decode.ImageDecoderDecoder&#13;&#10;import coil.disk.DiskCache&#13;&#10;import coil.memory.MemoryCache&#13;&#10;&#13;&#10;class MyApplication : Application(), ImageLoaderFactory {&#13;&#10;    override fun onCreate() {&#13;&#10;        super.onCreate()&#13;&#10;        // Initialiseer de UserManager zodra de app start&#13;&#10;        UserManager.init(this)&#13;&#10;        createNotificationChannel()&#13;&#10;        // Initialize CastManager so it's ready to handle casting requests&#13;&#10;        CastManager.initialize(this)&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun newImageLoader(): ImageLoader {&#13;&#10;        return ImageLoader.Builder(this)&#13;&#10;            .memoryCache {&#13;&#10;                MemoryCache.Builder(this)&#13;&#10;                    .maxSizePercent(0.25)&#13;&#10;                    .build()&#13;&#10;            }&#13;&#10;&#13;&#10;            .diskCache {&#13;&#10;                DiskCache.Builder()&#13;&#10;                    .directory(this.cacheDir.resolve(&quot;image_cache&quot;))&#13;&#10;                    .maxSizePercent(0.02)&#13;&#10;                    .build()&#13;&#10;            }&#13;&#10;            .components {&#13;&#10;                if (Build.VERSION.SDK_INT &gt;= 28) {&#13;&#10;                    add(ImageDecoderDecoder.Factory())&#13;&#10;                } else {&#13;&#10;                    // Fallback for older API levels if needed&#13;&#10;                }&#13;&#10;            }&#13;&#10;            .build()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun createNotificationChannel() {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#13;&#10;            val name = &quot;Twitch Chat Service&quot;&#13;&#10;            val descriptionText = &quot;Notification channel for the chat service&quot;&#13;&#10;            val importance = NotificationManager.IMPORTANCE_LOW&#13;&#10;            val channel = NotificationChannel(ChatService.CHANNEL_ID, name, importance).apply {&#13;&#10;                description = descriptionText&#13;&#10;                // Ensure chat channel is silent by default&#13;&#10;                setSound(null, null)&#13;&#10;                enableVibration(false)&#13;&#10;            }&#13;&#10;            val notificationManager:&#13;&#10;                    NotificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#13;&#10;            notificationManager.createNotificationChannel(channel)&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>